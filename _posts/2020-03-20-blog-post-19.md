---
title: 'Database'
date: 2020-03-20
permalink: /posts/2020/03/blog-post-19/
tags:
  - Note
---

This is my personal notes for Database.


数据库范式
-----------------
* 第一范式: 列不可分  

  第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。  

  举例: 联系人表(姓名，性别，电话），一个联系人有家庭电话和公司电话，那么这种表结构设计就没有达到 1NF；

* 第二范式: 确保表中的每列都完全依赖主键

  第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。

  举例: 订单表(商品名称, 商品单价, 商品数量, 下单时间), 商品数量, 下单时间完全依赖订单ID，但是商品单价, 商品名称缺依赖的是商品ID, 所以要拆分成订单表和商品表。

* 第三范式: 确保每列都和主键列直接依赖,而不是间接依赖  

  第三范式需要确保数据表中的每一列数据都和主键直接依赖，而不能间接依赖。

  举例: 订单表(商品数量, 下单时间, 客户ID, 客户姓名, 客户城市), 客户姓名和客户城市依赖客户ID, 间接依赖订单ID，要将客户信息单独拆分成客户信息表。


-----------------------------------

数据库索引
-------------

索引是对数据库表中一个或多个列的值进行排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B_TREE及其变种。索引加速了数据访问，因为存储引擎不会再去扫描整张表得到需要的数据；相反，它从根节点开始，根节点保存了子节点的指针，存储引擎会根据指针快速寻找数据。


* 1 索引的底层实现原理和优化

  　　在数据结构中，我们最为常见的搜索结构就是BST和AVL树(高度平衡的二叉搜索树，为了提高二叉搜索树的效率，减少树的平均搜索长度)了。然而，无论BST还是AVL树，当数据量比较大时，都会由于树的深度过大而造成I/O读写过于频繁，进而导致查询效率低下，因此对于索引而言，**多叉树** 结构成为不二选择。特别地，B-Tree的各种操作能使B树保持较低的高度，从而保证高效的查找效率。

  * B-Tree:  

    B-Tree将所有的值通过有序的多结点树结构排列, B-Tree的阶代表节点最多的孩子节点个数, 2-3树是3阶B-Tree, 注意其节点是有序排列的值, 所以搜索不一定会到叶子节点, 可能在上层就找到了target
    ![avatar](http://static.zybuluo.com/Rico123/z13w648etta3tb90di3btu5b/%E7%B4%A2%E5%BC%95.png)

  
  * B+Tree (InnoDB存储引擎的索引实现)

    B+Tree和B-Tree的区别在于B+Tree只在叶子节点顺序记录真正的值, 而上层节点都只记录其孩子节点的最大值(最小值), 相当于上层都是索引, 所以每次搜索都会搜索到叶子节点找到target  
    ![avatar](http://static.zybuluo.com/Rico123/ynugdx0avoy5blfq6gkb0tv2/3%E9%98%B6B+%E6%A0%91.jpg)

* 2 为什么说B+-tree比B 树更适合实际应用中操作系统的文件索引和数据库索引？


    **数据库索引采用B+树而不是B树的主要原因**：  
    B+树只要遍历叶子节点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频繁的，而B树只能中序遍历所有节点，效率太低

    B+tree的磁盘读写代价更低(IO更少)：B+tree的内部结点并没有指向关键字具体信息的指针，没有指向磁盘中具体的地址, 因此其内部结点相对B-Tree更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多，相对来说IO读写次数也就降低了；

    B+tree的查询效率更加稳定：由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引，所以，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当；


* 3 索引的优缺点

  优点:

  * (1) 大大加快数据的检索速度，这也是创建索引的最主要的原因；

  * (2) 加速表和表之间的连接；

  * (3) 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间；

  * (4) 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性；

  缺点:

  * (1) 时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度, 比如插入数据的速度会变慢

  * (2) 空间方面：索引需要占物理空间。(大的索引内存存不下还要放到磁盘里)

* 4 什么情况下设置了索引但无法使用？  

    (1) 以“%”开头的LIKE语句，模糊匹配；

    (2) OR语句前后没有同时使用索引；

    (3) 字符串没有加引号 eg: num = 123（如varchar不加单引号的话会自动转换为int型)

    (4) 对于多列索引，必须满足 最左匹配原则 (eg：多列索引col1、col2和col3，则 索引生效的情形包括 col1 或者 col1，col2 或者 col1，col2，col3)。

* 5 什么样的字段适合创建索引？

    经常作查询选择的字段 (select)

    经常作表连接的字段 (join)

    经常出现在where, order by, group by 后面的字段

* 6 创建索引时需要注意什么？

    表的主键、外键必须有索引；  
    数据量超过300的表应该有索引；  
    经常与其他表进行连接的表，在连接字段上应该建立索引；  
    经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；  
    索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；  
    联合索引的建立需要进行仔细分析, 尽量考虑用单字段索引代替
    非空字段：应该指定建立索引的列为NOT NULL

* 7 索引的分类

    (1) 普通索引和唯一性索引：索引列的值的唯一性

    (2) 单个索引和联合索引：索引列所包含的列数

    (3) 聚簇索引与非聚簇索引：  
    聚簇索引按照数据的物理存储进行划分的。对于一堆记录来说，使用聚集索引就是对这堆记录进行堆划分，即主要描述的是物理上的存储。正是因为这种划分方法，导致聚簇索引必须是唯一的。  
    聚集索引可以帮助把很大的范围，迅速减小范围。但是查找该记录，就要从这个小范围中Scan了；而非聚集索引是把一个很大的范围，转换成一个小的地图，然后你需要在这个小地图中找你要寻找的信息的位置，最后通过这个位置，再去找你所需要的记录。

* 8 主键、自增主键、主键索引与唯一索引概念区别  

    主键：指字段 唯一、不为空值 的列；

    主键索引：指的就是主键，主键是索引的一种，是唯一索引的特殊类型。创建主键的时候，数据库默认会为主键创建一个唯一索引；

    自增主键：字段类型为数字、自增、并且是主键；

    唯一索引：索引列的值必须唯一，但允许有空值。主键是唯一索引，这样说没错；但反过来说，唯一索引也是主键就错误了，因为唯一索引允许空值，主键不允许有空值，所以不能说唯一索引也是主键。

-----------------------------------

数据库事务
-------------

事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态

  * (1) 事务的特征

    原子性(Atomicity)：事务所包含的一系列数据库操作要么全部成功执行，要么全部回滚；

    一致性(Consistency)：事务的执行结果必须使数据库从一个一致性状态到另一个一致性状态；

    隔离性(Isolation)：并发执行的事务之间不能相互影响；

    持久性(Durability)：事务一旦提交，对数据库中数据的改变是永久性的。

  * (2) 事务并发带来的问题

    1、更新丢失：一个事务的更新覆盖了另一个事务的更新。事务A：更新money=100。事务B：更新money=200。A,B同时执行，后提交的事务B覆盖了事务A的更新。更新丢失本质上是写操作的冲突，解决办法是**一个一个写**。

    2、脏读：一个事务读取了另一个事务未提交的数据。事务A：更新money+=100。事务B：查询money。事务A发生后（还未提交），事务B查询money多了100元。事务A由于某种问题，比如超时，进行回滚。事务B查询到的数据是假数据。脏读本质上是读写操作的冲突，解决办法是**写完再读**。

    3、不可重复读：一个事务两次读取同一个数据，两次读取的数据不一致。事务A：money+=100。事务B：两次查询money。事务B第一次查询money，事务A还没有发生，第二次查询money，事务A已经发生了，导致一个事务中，两次读取同一个数据，读取的数据不一致。不可重复读本质上是读写操作的冲突，解决办法是**读完再写**。(不可重复读重点在于update和delete, 数据不一致)

    4、幻象读：一个事务两次读取一个范围的记录，两次读取的记录数不一致。事务A：查询id=1的记录。事务B：插入id=1的记录。事务A第一次查询的时候，id=1不存在，准备insert id=1的记录(insert也要先读), 而此时事务B已经执行, 导致主键冲突insert失败。幻象读本质上是读写操作的冲突, 解决办法是**读完再写**。(幻读的重点在于insert, 有和无)

  

  




  











