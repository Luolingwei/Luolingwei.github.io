---
title: 'Java Advanced'
date: 2020-03-10
permalink: /posts/2020/03/blog-post-19/
tags:
  - Interview
---

This is my personal notes for Java Advanced.

-----------------------------------

JVM 堆栈
-------------
* 基本概念

  寄存器：最快的存储区, 由编译器根据需求进行分配,我们在程序中无法控制.

  栈：存放基本类型的变量数据和对象的引用，但对象本身不存放在栈中，而是存放在堆（new 出来的对象）或者常量池中（字符串常量对象存放在常量池中。）

  堆：存放所有new出来的对象。

  静态域：存放静态成员（static定义的）

  常量池：存放字符串常量和基本类型常量（public static final）。

  非RAM存储：硬盘等永久存储空间

  从堆和栈的功能和作用来通俗的比较,堆主要用来存放对象的，栈主要是用来执行程序的.

* JVM 堆栈

  JAVA的JVM的内存可分为3个区：堆(heap)、栈(stack)和方法区(method)

  * 栈区: 

    每个线程包含一个栈区，栈中只保存方法中（不包括对象的成员变量）的基础数据类型和自定义对象的引用(不是对象)，对象都存放在堆区中, 每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。
  
  * 堆区: 
  
    存储的全部是对象实例，每个对象都包含一个与之对应的class的信息(class信息存放在方法区)。jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身，几乎所有的对象实例和数组都在堆中分配。 在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。
  
  * 方法区: 
  
    又叫静态区，跟堆一样，被所有的线程共享。它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

-----------------------------------

Java垃圾回收(GC)
-----------------

* 1 确定对象是否可以回收

  * a 引用计数算法：判断对象的引用数量

    堆中的每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个引用变量，该对象实例的引用计数设置为 1。当任何其它变量被赋值为这个对象的引用时，对象实例的引用计数加 1（a = b，则b引用的对象实例的计数器加 1，但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数减 1。特别地，当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器均减 1。任何引用计数为0的对象实例可以被当作垃圾收集。

  * b 可达性分析算法：判断对象的引用链是否可达

    可达性分析算法是通过判断对象的引用链是否可达来决定对象是否可以被回收。

    把所有的引用关系看作一张图，通过GC Roots作为起始点，从这些节点开始向下搜索，从GC Roots不可到达的对象是不可用的。 
  
    GC Roots包括:   
    (1) 虚拟机栈(栈帧中的局部变量表)中引用的对象  
    (2) 方法区中类静态属性引用的对象  
    (3) 方法区中常量引用的对象  
    (4) 本地方法栈中Native方法引用的对象

* 2 垃圾回收算法

  * a 标记清除算法   
    用freeList进行空闲内存的记录, 该算法首先从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象并进行回收

    缺点:   
    (1) 标记和清除两个过程的效率都不高;  
    (2) 用freeList不需要移动对象, 但是会存在内存碎片化的问题, 比如5k的内存放入了一个4.9k的对象

  * b 标记整理算法  
    用heap pointer进行空闲内存的记录,  该算法对集合进行扫描, 对不存活的对象进行压缩, 分配时直接移动heap pointer进行对应size内存的分配，不存在碎片化问题, 适用于老年代场景, 不需要很多的压缩清理

    标记整理算法与标记清除算法最显著的区别是：标记清除算法不进行对象的移动，并且仅对不存活的对象进行处理；而标记整理算法会将所有的存活对象移动到一端，并对不存活对象进行压缩清理，因此其不会产生内存碎片。但是其内存reclaim的代价要更高, 因为要移动存活对象。

  * c 复制算法
    将内存划分成2块相同size的heap, 当一个heap满的时候, 将其中的存活对象复制到另一个heap中, 清空当前heap。同样不存在碎片化问题, 适用于新生代, 如果对象存活率太高, 就会频繁的溢出复制, 效率降低

  * d 分代收集算法
    对于一个大型的系统，当创建的对象和方法变量比较多时，堆内存中的对象也会比较多，如果逐一分析对象是否该回收，那么势必造成效率低下。
    
    当代商用虚拟机使用的都是分代收集算法：新生代对象存活率低，就采用复制算法；老年代存活率高，就用标记清除算法或者标记整理算法。Java堆内存一般可以分为新生代、老年代和永久代三个模块，如下图所示：

    ![avatar](http://static.zybuluo.com/Rico123/bqgcx5anvacebj1yxpaufk0x/%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E6%80%BB.jpg)


* 3 垃圾回收类型   

  由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。垃圾回收有两种类型，**Minor GC** 和 **Full GC**。

  * a Minor GC：对新生代进行回收，不会影响到年老代。因为新生代的 Java 对象大多死亡频繁，所以 Minor GC 非常频繁，一般在这里使用速度快、效率高的算法，使垃圾回收能尽快完成。

  * b Full GC：也叫 Major GC，对整个堆进行回收，包括新生代和老年代。由于Full GC需要对整个堆进行回收，所以比Minor GC要慢，因此应该尽可能减少Full GC的次数，导致Full GC的原因包括：老年代被写满、永久代（Perm）被写满和System.gc()被显式调用等。

* 4 总结  

  ![avatar](https://img-blog.csdn.net/20170515153931088?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


-----------------------------------

Java 单例模式
-------------

单例模式核心在于为整个系统提供一个唯一的实例，为整个系统提供一个全局访问点。单例模式从实现上可以分为**饿汉式单例**和**懒汉式单例**两种，前者天生就是线程安全的，后者则需要考虑线程安全性，常见的线程安全的懒汉式单例的实现有内部类式和双重检查式两种。下面给出单例模式几种常见的形式：

(1) 饿汉式单例  

```java
// 饿汉式单例
public class Singleton1 {

    // 指向自己实例的私有静态引用，主动创建
    private static Singleton1 singleton1 = new Singleton1();

    // 私有的构造方法
    private Singleton1(){}

    // 以自己实例为返回值的静态的公有方法，静态工厂方法
    public static Singleton1 getSingleton1(){
        return singleton1;
    }
}
```
用空间换时间，天生线程安全

(2) 懒汉式单例 (线程不安全)

```java
// 懒汉式单例
public class Singleton2 {

    // 指向自己实例的私有静态引用
    private static Singleton2 singleton2;

    // 私有的构造方法
    private Singleton2(){}

    // 以自己实例为返回值的静态的公有方法，静态工厂方法
    public static Singleton2 getSingleton2(){
        // 被动创建，在真正需要使用时才去创建
        if (singleton2 == null) {
            singleton2 = new Singleton2();
        }
        return singleton2;
    }
}
```

(3) 线程安全的懒汉式单例 —— 加同步

```java

public class Singleton {

    // volatile： 防止指令重排序
    private volatile static Singleton instance;

    private Singleton() {

    }

    public static synchronized Singleton getInstance() {  
        if (instance == null) {    
            instance = new Singleton();  
        }    
        return instance;  
    }  

}

缺点: 在方法调用上加了同步，虽然线程安全了，但是每次都要同步，会影响性能，毕竟99%的情况下是不需要同步的

```

(4) 线程安全的懒汉式单例 —— 双重检查方式

```java
public class Singleton {

    // volatile： 防止指令重排序
    private volatile static Singleton instance;

    private Singleton() {

    }

    public static Singleton getInstance() {
        // 第一次检查
        if(instance == null){
            // 只在最初几次会进入该同步块，提高效率
            synchronized(Singleton.class){
                // 第二次检查
                if(instance == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```
DCL((Double Check Lock))模式的优点就是，在getInstance中做了两次null检查，确保了只有第一次调用单例的时候才会做同步，这样是线程安全的，同时避免了每次都同步的性能损耗。但是，由于jvm存在乱序执行功能，DCL也会出现线程不安全的情况。具体分析如下：
```java
INSTANCE  = new SingleTon(); 
```
1.在堆内存开辟内存空间。  
2.在堆内存中实例化SingleTon里面的各个参数。  
3.把对象指向堆内存空间。  

由于jvm存在乱序执行功能，所以可能在2还没执行时就先执行了3，如果此时再被切换到线程B上，由于执行了3，INSTANCE 已经非空了，会被直接拿出来用，这样的话，就会出现异常。这个就是著名的DCL失效问题。

不过在JDK1.5之后，官方也发现了这个问题，故而具体化了volatile，即在JDK1.6及以后，只要定义为private volatile static SingleTon instance, 就可解决DCL失效问题。volatile确保INSTANCE每次均在主内存中读取，这样虽然会牺牲一点效率，但也无伤大雅。


(5) 线程安全的懒汉式单例 —— 内部类方式 (推荐)

```java
public class Singleton {
    //静态私有内部类
    private static class InnerClass {
        private static final Singleton instance = new Singleton();
    }

    private Singleton(){

    }

    public static Singleton getInstance(){
        return InnerClass.instance;
    }
}

```

静态内部类的优点是：外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化instance，又因为JVM可以保证类初始化的线程安全, 所以这种方法是线程安全的,且也能保证单例的唯一性，同时也延迟了单例的实例化。

内部类模式类似饿汉模式, 不过是加载内部类时才开启饿汉模式。

关于JVM保证类初始化的线程安全,《深入理解JAVA虚拟机》中，有这么一句话:

虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，就可能造成多个进程阻塞。需要注意的是，其他线程虽然会被阻塞，但如果执行<clinit>()方法后，其他线程唤醒之后不会再次进入<clinit>()方法。同一个加载器下，一个类型只会初始化一次。在实际应用中，这种阻塞往往是很隐蔽的。

缺点: 因为是静态内部类的形式去创建单例的，故外部无法传递参数进去，例如Context这种参数, DCL使用new Singleton()的方式在getInstance中创建, 可以传参。

-----------------------------------

JVM 调优
-------------

JVM 调优的主要目标是使系统具有 **高吞吐 、低停顿** 的特点，其优化可以通过调整JVM的参数并通过相应的工具监测效果进行, 可以调整的参数主要包括:

* JVM 参数

  * a -Xmx   
  Java heap的最大值，默认值为物理内存的1/4，最佳设值应该视物理内存大小及计算机内其他内存开销而定；
  * b -Xms   
  Java heap初始值，Server端JVM最好将-Xms和-Xmx设为相同值，开发测试机JVM可以保留默认值；
  * c -Xmn   
  Java heap 中 Young区(新生代)大小
  * d -Xss   
  每个线程的stack大小

  IDEA中的JVM默认参数(vmoptions中可查看)
  ```shell
    -Xms128m
    -Xmx1024m
    -XX:ReservedCodeCacheSize=240m
    -XX:+UseConcMarkSweepGC
    -XX:SoftRefLRUPolicyMSPerMB=50
    -ea
    -XX:CICompilerCount=2
    -Dsun.io.useCanonPrefixCache=false
    -Djava.net.preferIPv4Stack=true
  ```

* 调优工具

  * Jconsole

    JConsole 可以直接从IDEA terminal中调用, 其可以监控 Java 应用程序性能和跟踪 Java 中的代码

  * Visual VM

    IDEA需要在Plugin中安装Visual VM

  * (terminal命令) jps

    显示所有进程的pid
  
  * (terminal命令) jstack [-l][-e] <pid>

    可以查看某个Java进程内的线程堆栈信息，主要用于线程Dump分析


-----------------------------------

类的生命周期及其初始化时机
-------------

类的生命周期主要包括加载、链接、初始化、使用和卸载五个阶段，如下图所示：

其中，虚拟机规范指明 **有且只有** 五种情况必须立即对类进行初始化，包括：

* 1 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时

  注意，newarray指令触发的只是数组类型本身的初始化，而不会导致其相关类型的初始化，比如，new String[]只会直接触发String[]类的初始化，也就是触发对类[Ljava.lang.String的初始化，而直接不会触发String类的初始化时，如果类没有进行过初始化，则需要先对其进行初始化。生成这四条指令的最常见的Java代码场景是：

  * 使用new关键字实例化对象的时候；

  * 读取或设置一个类的静态字段（被final修饰，已在编译器把结果放入常量池的静态字段除外）的时候；

  * 调用一个类的静态方法的时候。

* 2 对类进行反射调用时

  使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。

* 3 初始化子类时  

  当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
  
* 4 虚拟机启动时

  当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。

* 5 当使用jdk1.7动态语言支持时
  
  如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic, REF_putstatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化

-----------------------------------

类加载过程中各阶段的作用
-------------

* 1、 加载（Loading）

  * (1). 通过一个类的全限定名来获取定义此类的二进制字节流（并没有指明要从一个Class文件中获取，可以从其他渠道，譬如：网络、动态生成、数据库等）；

  * (2). 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；

  * (3). 在内存中(对于HotSpot虚拟就而言就是方法区)生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；

* 2、 验证（Verification）：  

  验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

* 3、准备(Preparation)：  

  准备阶段是正式为类变量(static 成员变量)分配内存并设置类变量初始值（零值）的阶段，这些变量所使用的内存都将在方法区中进行分配。

* 4、解析(Resolution)：  

  解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

* 5、初始化(Initialization)：  

  初始化阶段是执行类构造器<clinit>()方法的过程。虚拟机会保证一个类的类构造器<clinit>()在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的类构造器<clinit>()，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。特别需要注意的是，在这种情形下，其他线程虽然会被阻塞，但如果执行<clinit>()方法的那条线程退出后，其他线程在唤醒之后不会再次进入/执行<clinit>()方法，因为 在同一个类加载器下，一个类型只会被初始化一次。


-----------------------------------

内部类
-------------


内部类指的是在一个类的内部所定义的类，类名不需要和源文件名相同。在Java中，内部类是一个编译时的概念，一旦编译成功，内部类和外部类就会成为两个完全不同的类，共有四种类型：

* 类型

  * 成员内部类：  

    成员内部类是外围类的一个成员，是依附于外围类的，所以，只有先创建了外围类对象才能够创建内部类对象。也正是由于这个原因，成员内部类也不能含有 static 的变量和方法；

  * 静态内部类：  
    
    静态内部类，就是修饰为static的内部类，该内部类对象不依赖于外部类对象，就是说我们可以直接创建内部类对象，但其只可以直接访问外部类的所有静态成员和静态方法；

  * 局部内部类：

    局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效；

  * 匿名内部类：  

    定义匿名内部类的前提是，内部类必须要继承一个类或者实现接口，格式为 new 父类或者接口(){定义子类的内容(如函数等)}。也就是说，匿名内部类最终提供给我们的是一个 匿名子类的对象。

* 功能

  * 间接实现多继承

    ```java
        //父类Example1
        public class Example1 {
            public String name() {
                return "rico";
            }
        }

        //父类Example2
        public class Example2 {
            public int age() {
                return 25;
            }
        }

        //实现多重继承的效果
        public class MainExample {

            //内部类Test1继承类Example1
            private class Test1 extends Example1 {
                public String name() {
                    return super.name();
                }
            }

            //内部类Test2继承类Example2
            private class Test2 extends Example2 {
                public int age() {
                    return super.age();
                }
            }

            public String name() {
                return new Test1().name();
            }

            public int age() {
                return new Test2().age();
            }

            public static void main(String args[]) {
                MainExample mexam = new MainExample();
                System.out.println("姓名:" + mexam.name());
                System.out.println("年龄:" + mexam.age());
            }
        }

        // Output:
        // 姓名:rico
        // 年龄:25
    ```
    MainExample分别继承了Example1和Example2的方法

  * 实现隐藏

    一般的非内部类，是不允许有 private 与 protected 权限的，但内部类可以。这样可以将某些功能类放进外部类中，构成一个供外部类调用的模块，而外部是看不到的。


-----------------------------------

对象的创建过程
-------------

在Java中，创建一个对象常常需要经历如下几个过程：  

父类的类构造器<clinit>() -> 子类的类构造器<clinit>() -> 父类的实例构造器(成员变量和实例代码块，父类的构造函数) -> 子类的实例构造器(成员变量和实例代码块，子类的构造函数)。  

其中，类构造器<clinit>()由静态变量和静态语句块组成，而类的实例构造器<init>()由类的实例变量/语句块以及其构造函数组成。

-----------------------------------

Java异常机制
-------------

* 异常类型

  Java体系中异常的组织分类如下图所示，所有异常类型的根类为 Throwable，具体包括两大类：Error 与 Exception。其中，Error是指程序无法处理的错误，表示运行应用程序中较严重问题；Exception是指程序本身可以处理的错误，具体可分为运行时异常（派生于 RuntimeException 的异常） 和 其他异常。

  此外，从异常是否必须需要被处理的角度来看，异常又可分为不受检查异常和受检查异常两种情况：

  不受检查异常：派生于 Error 或 RuntimeException 的所有异常；

  受检查异常：除去不受检查异常的所有异常。

  ![avatar](http://static.zybuluo.com/Rico123/pgluejr2qhw1pihnh9ozrr57/%E5%BC%82%E5%B8%B8)

* finally子句

  下面着重介绍一下try catch中的finally子句，注意两点:
  * a 进入try, finally一定会执行

  * b finally总是会在控制转移语句之前执行(如return、break、throw和continue等)
  
  举例:

  (1) try执行，finally必然执行

  ```java

      public class Test {
        
        public static void main(String[] args) {  
            try {  
                System.out.println("try block");  
                return ;  
            } finally {  
                System.out.println("finally block");  
            }  
        }  
    }

      // Output:
      // try block 
      // finally block

  ```

  (2) finally在控制转移语句return之前执行

    ```java

      public class Test { 
          public static void main(String[] args) {  
              System.out.println("reture value of test() : " + test()); 
          } 

          public static int test(){ 
              int i = 1; 

              try {  
                  System.out.println("try block");  
                  i = 1 / 0; 
                  return 1;  
              }catch (Exception e){ 
                  System.out.println("exception block"); 
                  return 2; 
              }finally {  
                  System.out.println("finally block");  
              } 
          } 
      }

      // Output:
      // try block 
      // exception block 
      // finally block 
      // reture value of test() : 2

  ```

  (3) finally在控制转移语句throw之前执行


    ```java

      public class ExceptionSilencer { 
          public static void main(String[] args) { 
              try { 
                  throw new RuntimeException(); 
              } finally { 
                  // Using ‘return’ inside the finally block 
                  // will silence any thrown exception. 
                  return; 
              } 
          } 
      }

      // Output:
      // 无exception throw
  ```

-----------------------------------

七大设计原则
-------------

* 单一职责原则：高内聚，一个类只做它该做的事情；

* 接口隔离原则: 接口小而专，避免大而全；

* 依赖倒置原则：依赖抽象而非实现，面向接口编程；

* 里氏替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能；

* 开闭原则：Open for Extension, Closed for Modification，例如 AOP，代理模式，适配器模式就是其经典应用；

* 迪米特法则：高内聚，低耦合；

-----------------------------------

equals， hashCode， ==
-------------

* ==   
  用于判断两个对象是否为同一个对象或者两基本类型的值是否相等；

* equals   
  用于判断两个对象**内容**是否相同；

* hashCode   
  是一个对象的 消息摘要函数，一种 压缩映射，其一般与equals()方法同时重写；若不重写hashCode方法，默认使用Object类的hashCode方法，该方法是一个本地方法，由 Object 类定义的 hashCode 方法会针对不同的对象返回不同的整数 (对两个内容相同的对象hash会得到不同的整数)。


```java

    HashSet set1 = new HashSet();
    set1.add("1");
    set1.add("1");

    HashSet set2 = new HashSet();
    Person p1 = new Person("1");
    Person p2 = new Person("1");
    set2.add(p1);
    set2.add(p2);

    // 结果:
    // set1 1个元素
    // set2 2个元素
```

以上现象产生的原因是Person没有重写Person的equal和HashCode方法,导致对比两个对象的地址, 被视为2个不同的元素, 比较过程: 先调用HashCode比较HashCode是否相同, 如果相同再调用equals方法, 所以重写时需要equals和hashCode同时重写

```java

   static class Person {
        private String age;

        Person(String age) {
            this.age = age;
        }
        
        //重写equals()
        @Override
        public boolean equals(Object obj) {
            if (obj == null || !(obj instanceof Person)) {
                return false;
            }
            //地址相同必相等
            if (obj == this) {
                return true;
            }
            Person person = (Person) obj;
            //地址不同比较值是否相同
            return person.age.equals(this.age);
        }

        //重写hashCode()
        @Override
        public int hashCode() {
            return Objects.hash(age);
        }
   }

```
