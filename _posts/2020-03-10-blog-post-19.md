---
title: 'Java Advanced'
date: 2020-03-10
permalink: /posts/2020/03/blog-post-19/
tags:
  - Interview
---

This is my personal notes for Java Advanced.


Java垃圾回收(GC)
-----------------

* 1 确定对象是否可以回收

  * a 引用计数算法：判断对象的引用数量

    堆中的每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个引用变量，该对象实例的引用计数设置为 1。当任何其它变量被赋值为这个对象的引用时，对象实例的引用计数加 1（a = b，则b引用的对象实例的计数器加 1，但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数减 1。特别地，当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器均减 1。任何引用计数为0的对象实例可以被当作垃圾收集。

  * b 可达性分析算法：判断对象的引用链是否可达

    可达性分析算法是通过判断对象的引用链是否可达来决定对象是否可以被回收。

    把所有的引用关系看作一张图，通过GC Roots作为起始点，从这些节点开始向下搜索，从GC Roots不可到达的对象是不可用的。 
  
    GC Roots包括:   
    (1) 虚拟机栈(栈帧中的局部变量表)中引用的对象  
    (2) 方法区中类静态属性引用的对象  
    (3) 方法区中常量引用的对象  
    (4) 本地方法栈中Native方法引用的对象

* 2 垃圾回收算法

  * a 标记清除算法   
    用freeList进行空闲内存的记录, 该算法首先从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象并进行回收

    缺点:   
    (1) 标记和清除两个过程的效率都不高;  
    (2) 用freeList不需要移动对象, 但是会存在内存碎片化的问题, 比如5k的内存放入了一个4.9k的对象

  * b 标记整理算法  
    用heap pointer进行空闲内存的记录,  该算法对集合进行扫描, 对不存活的对象进行压缩, 分配时直接移动heap pointer进行对应size内存的分配，不存在碎片化问题, 适用于老年代场景, 不需要很多的压缩清理

    标记整理算法与标记清除算法最显著的区别是：标记清除算法不进行对象的移动，并且仅对不存活的对象进行处理；而标记整理算法会将所有的存活对象移动到一端，并对不存活对象进行压缩清理，因此其不会产生内存碎片。但是其内存reclaim的代价要更高, 因为要移动存活对象。

  * c 复制算法
    将内存划分成2块相同size的heap, 当一个heap满的时候, 将其中的存活对象复制到另一个heap中, 清空当前heap。同样不存在碎片化问题, 适用于新生代, 如果对象存活率太高, 就会频繁的溢出复制, 效率降低

  * d 分代收集算法
    对于一个大型的系统，当创建的对象和方法变量比较多时，堆内存中的对象也会比较多，如果逐一分析对象是否该回收，那么势必造成效率低下。
    
    当代商用虚拟机使用的都是分代收集算法：新生代对象存活率低，就采用复制算法；老年代存活率高，就用标记清除算法或者标记整理算法。Java堆内存一般可以分为新生代、老年代和永久代三个模块，如下图所示：

    ![avatar](http://static.zybuluo.com/Rico123/bqgcx5anvacebj1yxpaufk0x/%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E6%80%BB.jpg)


* 3 垃圾回收类型   

  由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。垃圾回收有两种类型，**Minor GC** 和 **Full GC**。

  * a Minor GC：对新生代进行回收，不会影响到年老代。因为新生代的 Java 对象大多死亡频繁，所以 Minor GC 非常频繁，一般在这里使用速度快、效率高的算法，使垃圾回收能尽快完成。

  * b Full GC：也叫 Major GC，对整个堆进行回收，包括新生代和老年代。由于Full GC需要对整个堆进行回收，所以比Minor GC要慢，因此应该尽可能减少Full GC的次数，导致Full GC的原因包括：老年代被写满、永久代（Perm）被写满和System.gc()被显式调用等。

* 4 总结  

  ![avatar](https://img-blog.csdn.net/20170515153931088?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvanVzdGxvdmV5b3Vf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


-----------------------------------

Java 单例模式
-------------

单例模式一般用static实现, 在类内部定义static的instance, 将获取instance的函数设置为public, 并且将构造函数设置为private, 这样就不会被外部实例化, 只有一个内部的实例化对象

```java

  class SingleObject {

      //创建 SingleObject 的一个对象
      private static SingleObject instance = new SingleObject();

      //让构造函数为 private，这样该类就不会被实例化
      private SingleObject(){}

      //获取唯一可用的对象的接口, 暴露给外部
      public static SingleObject getInstance(){
          return instance;
      }

      public void showMessage(){
          System.out.println("Hello World!");
      }
  }

  class Test1{

      public static void main(String[] args) {
          SingleObject object = SingleObject.getInstance();
          object.showMessage();
      }
  }

// 输出
// Hello World!

```

-----------------------------------

JVM 堆栈
-------------
* 基本概念

  寄存器：最快的存储区, 由编译器根据需求进行分配,我们在程序中无法控制.

  栈：存放基本类型的变量数据和对象的引用，但对象本身不存放在栈中，而是存放在堆（new 出来的对象）或者常量池中（字符串常量对象存放在常量池中。）

  堆：存放所有new出来的对象。

  静态域：存放静态成员（static定义的）

  常量池：存放字符串常量和基本类型常量（public static final）。

  非RAM存储：硬盘等永久存储空间

  从堆和栈的功能和作用来通俗的比较,堆主要用来存放对象的，栈主要是用来执行程序的.

* JVM 堆栈

  JAVA的JVM的内存可分为3个区：堆(heap)、栈(stack)和方法区(method)

  * 栈区: 

    每个线程包含一个栈区，栈中只保存方法中（不包括对象的成员变量）的基础数据类型和自定义对象的引用(不是对象)，对象都存放在堆区中每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。
  
  * 堆区: 
  
    存储的全部是对象实例，每个对象都包含一个与之对应的class的信息(class信息存放在方法区)。jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身，几乎所有的对象实例和数组都在堆中分配。 在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。
  
  * 方法区: 
  
    又叫静态区，跟堆一样，被所有的线程共享。它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。




-----------------------------------

JVM 调优
-------------

JVM 调优的主要目标是使系统具有 **高吞吐 、低停顿** 的特点，其优化可以通过调整JVM的参数并通过相应的工具监测效果进行, 可以调整的参数主要包括:

* JVM 参数

  * a -Xmx   
  Java heap的最大值，默认值为物理内存的1/4，最佳设值应该视物理内存大小及计算机内其他内存开销而定；
  * b -Xms   
  Java heap初始值，Server端JVM最好将-Xms和-Xmx设为相同值，开发测试机JVM可以保留默认值；
  * c -Xmn   
  Java heap 中 Young区(新生代)大小
  * d -Xss   
  每个线程的stack大小

  IDEA中的JVM默认参数(vmoptions中可查看)
  ```shell
    -Xms128m
    -Xmx1024m
    -XX:ReservedCodeCacheSize=240m
    -XX:+UseConcMarkSweepGC
    -XX:SoftRefLRUPolicyMSPerMB=50
    -ea
    -XX:CICompilerCount=2
    -Dsun.io.useCanonPrefixCache=false
    -Djava.net.preferIPv4Stack=true
  ```

* 调优工具

  * Jconsole

    JConsole 可以直接从IDEA terminal中调用, 其可以监控 Java 应用程序性能和跟踪 Java 中的代码

  * Visual VM

    IDEA需要在Plugin中安装Visual VM

  * (terminal命令) jps

    显示所有进程的pid
  
  * (terminal命令) jstack [-l][-e] <pid>

    可以查看某个Java进程内的线程堆栈信息，主要用于线程Dump分析
