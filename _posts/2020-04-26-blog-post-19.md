---
title: 'Computer Networks'
date: 2020-04-26
permalink: /posts/2020/04/blog-post-19/
tags:
  - Note
---

This is my personal notes for Computer Networks.


TCP/IP协议各层的作用
-----------------
* 应用层(Application)：应用层的任务是通过应用进程之间的交互来完成特定网络应用。应用层协议定义的是应用进程间通信和交互的规则。这里的进程是指主机中正在与运行的程序。对于不同的网络应用需要有不同的应用层协议。在互联网中的应用层协议有很多，如域名系统DNS，支持万维网应用的HTTP协议，支持电子邮件的SMTP协议，等等。

* 传输层(Transport)：传输层的任务是负责向两台主机中进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。主要有TCP协议和UDP协议。

* 网络层(Network)：网络层的任务是为分组交换网上的不同主机提供通信服务。在发送数据的时候，网络层把运输层产生的报文段或者用户数据报封装成分组或包进行传送。主要使用IP协议。

* 网络接口层(Link)：操作系统中的设备驱动和计算机对应的网络接口，它们一起处理与传输媒介的物理接口细节。主要有ARP协议和RARP协议。

-----------------------------------

TCP和UDP的区别
-------------

* 连接：UDP是无连接的，发送数据之前无需建立连接，发送数据结束后也无需释放连接。TCP是面向连接的，在发送数据之前需要通过三次握手建立连接，发送数据结束后需要通过四次挥手释放连接。

* 交付：UDP使用尽最大努力交付，即不保证可靠交付，主机不需要维持复杂的连接状态表。TCP提供可靠交付，即通过TCP连接传送的数据，无差错、不丢失、不重复，并且按序到达。

* 数据：UDP是面向报文的，UDP对于应用层交下来的报文，添加首部后就向下交给IP层，既不合并，也不拆分，一次交付一个完整的报文。TCP是面向字节流的，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据看出成一连串无结构的字节流。TCP不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小关系。

* 通信双方：UDP支持一对一、一对多、多对一、多对多的交互通信。TCP连接是点对点（一对一），每一条TCP连接只能有两个端点。

* 拥塞：UDP没有拥塞控制，网络的拥塞不会使源主机的发送速率降低。TCP通过慢开始、拥塞避免、快重传、快恢复等算法进行拥塞控制。

* 首部：UDP首开销小，只有8个字节。TCP首部是20个字节。

<img src="./pictures/01.png" width="500"/>
<div align="center">
    <img src="./pictures/01.png" width="500"/>
</div>
<div align="center">
    <img src="pictures/02.png" width="500"/>
</div>

-----------------------------------

TCP的三次握手与四次挥手
--------------------
三次握手(我要和你建立链接，你真的要和我建立链接么，我真的要和你建立链接，成功)

* 第一次握手(SYN=1, seq=x):

  客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。

  发送完毕后，客户端进入 SYN_SEND 状态。

* 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):

  服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。

* 第三次握手(ACK=1，ACKnum=y+1)

  客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1

  发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。

<div align="center">
    <img src="pictures/03.png"/>
</div>

四次挥手 (我要和你断开链接；好的，断吧。我也要和你断开链接；好的，断吧)

* 第一次挥手(FIN=1，seq=x)

  假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。

  发送完毕后，客户端进入 FIN_WAIT_1 状态。

* 第二次挥手(ACK=1，ACKnum=x+1)

  服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。

  发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。

* 第三次挥手(FIN=1，seq=y)

  服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。

  发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。

* 第四次挥手(ACK=1，ACKnum=y+1)

  客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。

  服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。

  客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。

<div align="center">
    <img src="./pictures/04.png"/>
</div>

-----------------------------------

为什么TCP链接需要三次握手，而不是四次/两次？
-----------------------------------------
关键点: TCP是有序可靠的, 需要通信双方互相确认对方的序列号

* 四次握手:  
  * 1.1 client 发送 SYN = 1, seq = x (client的序列号)
  * 1.2 server 发送 ACK = 1, ack = x+1  (准备接收的序列号)
  * 1.3 server 发送 SYN = 1, seq = y (server的序列号)
  * 1.4 client 发送 ACK = 1, seq = x+1, ack = y+1 (准备接收的序列号)

  很明显, 1.2和1.3可以合并, 提高连接速度和效率

* 两次握手:  
  * 1.1 client 发送 SYN = 1, seq = x
  * 1.2 server 发送 ACK = 1, ack = x+1, SYN = 1, seq = y  

  此时, client并没有确认server的序列号，不符合TCP有序可靠的要求

* 三次握手:
  * 1.1 client 发送 SYN = 1, seq = x
  * 1.2 server 发送 ACK = 1, ack = x+1, SYN = 1, seq = y 
  * 1.3 client 发送 ACK = 1, seq = x+1, ack = y+1

  此时, 双方互相确认了对方的序列号

* 补充:  
  * 1 如果第1个包丢失, client的SYN没有到达server:  
client会周期性超时重传, 直到收到server的确认   
  * 2 如果第2个包丢失, server的ACK+SYN没有到达client:    
server会周期性超时重传, 直到收到client的确认  
  * 3 如果第3个包丢失, client的ACK没有到达server:  
如果双方都没有发送数据, server会周期性超时重传 SYN+ACK, 直到收到client的确认, 建立连接  
如果此时client有数据发送, server收到client的 Data+ACK, 接收数据并建立连接  

  **TCP不会为没有数据的ACK超时重传**

-----------------------------------

TCP协议如何来保证传输的可靠性
-------------------------
TCP提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过TCP链接交换8bit字节构成的字节流，TCP不在字节流中插入记录标识符。

对于可靠性，TCP通过以下方式进行保证：

* 数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；

* 对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；

* 丢弃重复数据：对于重复数据，能够丢弃重复数据；

* 应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；

* 超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；

* 流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。

-----------------------------------

TCP的拥塞处理
-------------------------
计算机网络中的带宽、交换结点中的缓存及处理机等都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，这种情况就叫做拥塞。拥塞控制就是 防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。注意，拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。拥塞控制的方法主要有以下四种：

* 1 慢启动：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小;
* 2 拥塞避免：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按线性规律缓慢增长。
* 3 快重传：快重传要求接收方在收到一个 失序的报文段 后就立即发出 重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。
* 4 快恢复：快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。


-----------------------------------

Http和Https的区别
-----------------

Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同：

* 端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443；

* 资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；

* 开销：Https通信需要证书，而证书一般需要向认证机构购买；  

Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。

-----------------------------------

对称加密与非对称加密
-----------------

* 对称加密  
对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方

* 非对称加密  
非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。  

* 对称加密 + 非对称加密  
由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。

-----------------------------------

客户端不断进行请求链接会怎样？DDos(Distributed Denial of Service)攻击？
-----------------------------------

* 1、DDos 攻击

  客户端向服务端发送请求链接数据包  
  服务端向客户端发送确认数据包  
  客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认

* 2、DDos 预防 ( **没有彻底根治的办法，除非不使用TCP** )

  限制同时打开SYN半链接的数目  
  缩短SYN半链接的Time out 时间  
  关闭不必要的服务

-----------------------------------

Get与POST的区别
-----------------------------------

GET与POST是我们常用的两种HTTP Method，二者之间的区别主要包括如下五个方面：

* 1 从功能上讲，GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源；

* 2 从REST服务角度上说，GET是幂等的，即读取同一个资源，总是得到相同的数据，而POST不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET不会改变服务器上的资源，而POST会对服务器资源进行改变；

* 3 从请求参数形式上看，GET请求的数据会附在URL之后，即将请求数据放置在HTTP报文的 **请求头** 中，以?分割URL和传输数据，参数之间以&相连。特别地，如果数据是英文字母/数字，原样发送；如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD %A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII)；而POST请求会把提交的数据则放置在是HTTP请求报文的 **请求体** 中。

* 4 就安全性而言，POST的安全性要比GET的安全性高，因为GET请求提交的数据将明文出现在URL上，而且POST请求参数则被包装到请求体中，相对更安全。

* 5 从请求的大小看，GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。

-----------------------------------

从输入网址到获得页面的过程
-----------------------------------

* 1 浏览器查询 DNS，获取域名对应的IP地址:具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；

* 2 浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手；

* 3 TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求；

* 4 服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；

* 5 浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；

* 6 浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。
