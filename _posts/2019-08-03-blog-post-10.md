---
title: 'Java Foundation'
date: 2019-08-03
permalink: /posts/2019/08/blog-post-10/
tags:
  - Note
---

This is my personal notes for Java Foundation.


Introduction
------
本文介绍Java基础知识

-------------------

String，StringBuilder, StringBuffer
-----------

* String (不可变，线程安全)

  String类是final类，也即意味着String类不能被继承

  String是用char[]存储的, 其属性字段基本都是final的, 所以是不可变的  

  无论是sub、concat还是replace操作都不是inplace操作，而是重新生成了一个新的字符串对象


  * String直接赋值和new String()的区别

    * 直接赋值

      ```java
        String str1 = "hello";
        String str2 = "hello";
        String str3 = "world";
      ```
      生成了2个对象  
      这样创建字符串，首先会去常量池里找有没有这个字符串，有就直接指向常量池的该字符串，没有就先往常量池中添加一个，再指向它。图解：

      ![avatar](https://pic2.zhimg.com/80/v2-3b19aa93549d952756616011ef368e39_720w.jpg)

    * 用new创建

      ```java
        String str1 = new String("hello");
        String str2 = new String("hello");
        String str3 = new String("world");
      ```
      生成了5个对象  
      new一个字符串时，做了两件事。首先在堆中生成了该字符串对象，然后去看常量池中有没有该字符串，如果有就不管了，没有就往常量池中添加一个。图解：

      ![avatar](https://pic4.zhimg.com/80/v2-c8c7e43ffcbca3b6f69a01900901e2c7_720w.jpg)

    这两种方式创建的对象一种在常量池中一种在堆中, 所以用==比较会是false

  * StringBuilder(可变，线程不安全)

    String的+=操作底层是使用StringBuilder完成的  

    以下代码, JVM会优化成StringBuilder进行append, 循环10000次会在堆中new出10000个对象。

    ```java

      public class Main {
              
          public static void main(String[] args) {
              String string = "";
              for(int i=0;i<10000;i++){
                  string += "hello";
              }
          }

        // JVM执行方式
        StringBuilder str = new StringBuilder(string);

    　　str.append("hello");

    　　str.toString();
          
      }

    ```

    而如果直接使用StringBuilder, 则只会new一次对象, append操作是在原有对象的基础上进行的, 所占的资源要比上面小得多

    ```java

        public class Main {
                
            public static void main(String[] args) {
                StringBuilder stringBuilder = new StringBuilder();
                for(int i=0;i<10000;i++){
                    stringBuilder.append("hello");
                }
            }
        }

    ```

  * StringBuffer (可变，线程安全)

    StringBuffer和StringBuilder成员属性以及成员方法基本相同, 不同的是StringBuffer的方法前面都加上了**synchronized**, 所以StringBuffer是线程安全的。


  * 常见面试题

    * a String a = "hello2"; String b = "hello" + 2; System.out.println((a == b));

      输出结果为：true。原因很简单，"hello"+2在编译期间就已经被优化成"hello2"，因此在运行期间，变量a和变量b指向的是同一个对象。

    * b String a = "hello2"; String b = "hello"; String c = b + 2; System.out.println((a == c));

      输出结果为:false。由于有符号引用的存在，所以  String c = b + 2; 不会在编译期间被优化，不会把b+2当做常量来处理，因此这种方式生成的对象保存在堆上。而a保存在常量池中。

    * c String a = "hello2"; final String b = "hello"; String c = b + 2;    System.out.println((a == c));

      输出结果为：true。对于被final修饰的变量，会在class文件常量池中保存一个副本，也就是说不会通过连接而进行访问，对final变量的访问在编译期间都会直接被替代为真实的值。所以a和c都保存在常量池中。

    * d String str = new String("abc")创建了多少个对象？
    
      2个, 堆中1个, 常量池1个

    * e 1)和2)哪个更高效?  

      ```java
        public class Main {
            public static void main(String[] args) {
                String str1 = "I";
                //str1 += "love"+"java";        1)
                str1 = str1+"love"+"java";      //2)
                
            }
        }
      ```
      两者都会调用StringBuilder进行append, 1)的"love"+"java"会在编译时被优化成"lovejava", 而 2)会append两次。所以1)更高效。


-------------------

关键字
-----------

* 1 static

  * a 修饰成员变量  

    static关键字可以修饰成员变量，它所修饰的成员变量不属于对象的数据结构，而是属于类的变量，通常通过类名来引用static成员。

    当创建对象后，成员变量是存储在堆中的，而static成员变量和类的信息一起存储在方法区, 而不是在堆中

    一个类的static成员变量只有“一份”（存储在方法区）

    举例: 以下代码输出1, 2, 3, num对所有对象只有一份
    ```java

        class People {

            private int age;

            private static int num;

            public People(int age) {

              this.age = age;

              System.out.print(++num);

            }

        }

        public class StaticDemo {

            public static void main(String[] args) {

              People p1 = new People(18);

              People p2 = new People(19);

              People p3 = new People(20);

            }

        }

    ```

  * b 修饰方法

    static修饰的方法不需要针对某些对象进行操作，其运行结果仅仅与参数有关，调用的话直接用类名就可以调用了。(new 一个对象进行调用其实也可以)

        
    static方法中不能直接调用non-static方法, 但是可以间接通过对象的引用调用其non-static方法。


    ```java
      class Test2{
          public void method2(){
              System.out.println("HelloWorld2");
          }
      }

      class Test1 {

          public void method0(){
              System.out.println("HelloWorld0");
          }
          public static void method1() {
              System.out.println("HelloWorld1");
          }

          public static void main(String[] args) {
              // this.method0(); // 静态方法中不能用this, super等直接调用非静态方法
              new Test1().method0(); // 用对象的引用调用非静态方法method0
              Test1.method1(); // 直接用类名调用静态方法method1
              new Test2().method2(); // 用对象的引用调用非静态方法method2
          }

          // 输出
          // HelloWorld0
          // HelloWorld1
          // HelloWorld2
          
      }

    ```

  * c static块

      它是随着类的加载而执行，只执行一次，并优先于主函数。具体说，静态代码块是由类调用的。类调用时，先执行静态代码块，然后才执行主函数的。  
      静态代码块其实就是给类初始化的，而构造代码块是给对象初始化的。  
      静态代码块中的变量是局部变量，与普通函数中的局部变量性质没有区别。  
      一个类中可以有多个静态代码块

    ```java
        class Test1 {

            static int cnt=6;
            static{
                cnt+=9;
            }
            public static void main(String[] args) {
                System.out.println(cnt);
            }
            static{
                cnt/=3;
            }

        }

        // 输出
        // 5
    ```

  * d static类

      Java 的静态类只能是内部类, 其中的静态方法和成员可以直接通过内部类名在当前类被调用

      ```java
        class Test1 {

            private static class class1{
                static int i = 100;
            }

            public static void main(String[] args) {
                System.out.println(class1.i);
            }

        }

        // 输出
        // 100
      ```



* 2 final

  * a 修饰变量

    final意为不可改变，修饰成员变量时可以在声明时初始化或者在构造函数中初始化，修饰局部变量时在使用之前初始化。要是企图改变final修饰等变量值则会编译错误！

    ```java
      // 构造函数中初始化
      class Test1 {

          public final int cnt;

          Test1(){
              cnt = 4;
          }
          public static void main(String[] args) {
              System.out.println(new Test1().cnt);
          }

      }

      // 声明时初始化

      class Test1 {

          public final int cnt = 4;

          public static void main(String[] args) {
              System.out.println(new Test1().cnt);
          }

      }

    ```

  * b 修饰方法

    final修饰等方法不能被重写。

    ```java

      class Test1 {

          public final void method1(){
              System.out.println("this is method1");
          }

      }

      class Test2 extends Test1 {

          // 报错, method1不能被重写
          @Override
          public void method1() {
              super.method1();
          }
          
      }

    ```



  * c final修饰类

    final修饰等类不能被继承，jdk中的一些基本类库被定义成final，例如String，Math，Integer等，这样可以防止对系统造成危害。

    ```java

      final class Test1 {
          
      }

      // 报错, class Test1不可被继承
      class Test2 extends Test1{
          
          public static void main(String[] args) {
              System.out.println("Hello");
          }
          
      }

    ```

* 3 static final

  static final修饰的成员变量被成为常量，必须声明时初始化并且不可被改变，static final常量在编译期间会被取代为其初始值。

* 4 super

  访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super() 函数。  

  访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。

  ```java
    public class SuperExample {

        protected int x;
        protected int y;

        public SuperExample(int x, int y) {
            this.x = x;
            this.y = y;
        }

        public void func() {
            System.out.println("SuperExample.func()");
        }
    }


    public class SuperExtendExample extends SuperExample {

        private int z;

        public SuperExtendExample(int x, int y, int z) {
            super(x, y); // 调用父类的构造函数
            this.z = z;
        }

        @Override
        public void func() {
            super.func(); // 调用父类的实现部分
            System.out.println("SuperExtendExample.func()");
        }
    }

  ```



-------------------

参数传递
-----------

Java 的参数是以值传递的形式传入方法中，而不是引用传递  
传递对象时, 本质上是以值传递的方式传递地址

* Example1
  ```java
    class PassByValueExample {
        public static void main(String[] args) {
            Dog dog = new Dog("A");
            func(dog);
            System.out.println(dog.getName());          // B
        }

        private static void func(Dog dog) {
            dog.setName("B");
        }
    }
  ```
  将对象地址传进去, 修改之后对象属性会改变, 因为指向的是同一个对象

* Example2
  ```java
   class PassByValueExample {
        public static void main(String[] args) {
            Dog dog = new Dog("A");
            System.out.println(dog.getObjectAddress()); // Dog@4554617c
            func(dog);
            System.out.println(dog.getObjectAddress()); // Dog@4554617c
            System.out.println(dog.getName());          // A
        }

        private static void func(Dog dog) {
            System.out.println(dog.getObjectAddress()); // Dog@4554617c
            dog = new Dog("B");
            System.out.println(dog.getObjectAddress()); // Dog@74a14482
            System.out.println(dog.getName());          // B
        }
    }
  ```
  将对象地址传进去, 重新赋值, 会覆盖之前的地址, 生成新对象


-------------------

集合
-----------

(1) Array refers to a bunch of elements of same type stored in consecutive memory.    
(2) ArrayList is dynamic array, the size of it can be changed, element could be add and remove from the list. (by Array)  
(3) LinkedList is a linear data structure, in which elements are not stored in consecutive memory, each elements has 1 or more pointers to other elements. Typically, each element will be linked with the next element.  (by doubly Linked List)  
(4) HashMap is a data structure which stores data in key-value pair, to access a value, we must get its key, it is called HashMap because it uses Hashing, which means transfer a data block to a fixed range. (by array+LinkedList+Red-Black Tree)  
(5) HashSet is a data structure which stores unique element in random order,  no duplication is allowed, but there could be null. (by HashMap)   
(6) TreeMap is a ordered Map which is implemented by Red-Black Tree, the key is stored in natural order. (By Red-Black Tree)  
(7) TreeSet is a Ordered Set which is implemented by Red-Black Tree, the elements are stored in natural order. (By Red-Black Tree)  

* List

  List 和 Array的区别:  
  * 虽然Array的随机访问和存储效率高，但其不可伸缩，初始化的时候必须指定Size，这使得数据动态更新很不方便。而List无需声明Size，方便插入删除

  ArrayList 和 LinkedList的区别:  
  * ArrayList底层用Array实现，随机访问速度快O(1)，插入删除速度慢(O(n)). 当有大量访问操作时，使用ArrayList
  * LinkedList底层用doubly linked list实现，插入删除速度快(O(1))，随机访问速度慢(O(n)). 当有大量插入删除操作时，使用LinkedList  

  ```Java

    List<Integer> A=new ArrayList<>();
    List<Integer> B=new LinkedList<>();

    A.add(1) #在List末尾加入1 O(1)
    A.add(0,3) #在index=0的位置插入3，相当于insert O(n)
    A.remove(1) #删除索引为1的元素 O(n)
    A.remove(new Integer(1)) #删除元素 O(n)
    A.get(1) #取出索引为1的元素 O(1)

    A.addAll(A) #并入同类型的ArrayList
    A.size() #返回A中的元素个数
    A.isEmpty() #判断是否为空
    A.sort() #inplace 排序
    A.subList(0,2) #返回index为0和1的元素

    # LinkedList可以在头尾添加删除
    B.add(1) #在List末尾加入1 O(1) 
    B.add(0,3) #在index=0的位置插入3，相当于insert O(n)
    B.remove(1) #删除索引为1的元素 O(n)
    B.remove(new Integer(1)) #删除元素 O(n), 需要先找到包含该元素的node，O(n)+O(1)
    B.get(1) #取出索引为1的元素 O(n), 同样需要从链表头开始遍历

    B.addFirst() # O(1)
    B.addLast() # O(1)
    B.removeFirst() # O(1)
    B.removeLast()# O(1)

  ```

* Set

  * HashSet is implemented by HashMap, the element in HashSet is actually key in HashMap, the value is set as Present in corresponding HashMap, the element is unique because Key in HashMap is unique. When adding an element, call HashMap's put method, if key is already there, just update the value, adding will fail. Else adding wil succeed. When removing an element, call HashMap's remove function, if return value is Present, remove succeed. Else, remove will fail.

  ```Java

    Set<Character> B=new HashSet<>();
    Set<Character> C=new TreeSet<>();
    B.add('a'); #添加元素 
    B.remove('a'); #删除元素

    B.addAll(C) #B和C取并集
    B.size() #返回B的元素个数
    B.isEmpty() #判断是否为空
    B.sort() #返回排序后的List
    B.clear() #清空set

  ```

* Map  

  HashMap和HashTable的区别:
  * 1 HashMap is not thread-safe (not synchronised),  HashTable is thread-safe (synchronised)  
  * 2 There can be "null" in key, value of HashMap, but there can not be "null" in HashTable  
  // synchronised: when mutiple threads visit the HashMap, only 1 of them could make modification 

  HashMap的底层实现:  
  * HashMap底层用Array+LinkedList+(红黑树)实现
  * 初始化长度为16的数组，每个数组元素存链表的头结点，key对16取余数得到Hashcode(在数组中的index)
  * 为了防止各个链表长度过长影响get方法，当链表长度达到8时，转为红黑树，提高map效率  

  HashMap出现Hash碰撞怎么处理的:  
  * 用链表存储相同HashCode的value
  * 取的时候先计算出HashCode，然后遍历链表中节点的key寻找target  

  HashMap为什么是线程不安全的:
  * When amount of data exceed threshold, the HashMap will be resized, all elements will be rehashed. Deadlock will appear in Muti-thread rehashing.

  ![avatar](https://pic2.zhimg.com/80/v2-54ce9985f42a76d96ae1f25d05e2eac5_hd.jpg)

  TreeMap:  
  * It implements the interface sortedMap, the key in TreeMap would be in stored in natural order.  
  * If key is required to be in order, we can not use HashMap but use TreeMap instead.
  * TreeMap is implemented using Red-Black Tree.


  ```Java

    Map<Character,Integer> dic=new Hashmap<>();
    Map<Character,Integer> dic2=new TreeMap<>();
    dic.get('a'); #如果key不存在, 返回null
    dic.put('b',1); #存入pair(b,1),如果key已存在则更新
    dic.getOrDefault('a',0) #如果'a'不存在，取0
    dic.containsKey('a'); #判断'a'是否是dic中的key
    dic.size(); #返回dic中pairs个数
    dic.remove('a'); #删除dic中key为'a'的pair
    dic.clear(); #清空HashMap

    dic.keySet(); #以Set形式返回所有的key
    Set<Character> keys=dic.keySet();
    dic.values(); #返回一个包含values的collection集合,可以进一步转型存储
    List<Integer> values=new ArrayList<Integer>(dic.values());

  ```


-------------------

抽象类(abstract class)和接口(Interface)
-----------
* 抽象类

  抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。

  抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。


* 接口

  接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个**完全抽象**的类，也就是说它不能有任何的方法实现。Java 8 开始, 接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。

  interface 的默认方法在其实现类中可以不实现直接使用, 也可以重写实现。  
  interface 的方法必须是public  
  interface 的成员变量必须是 static 和 final 类型的  

  example:
  ```java
  public interface VideoService {

    public default void test(){
        System.out.println("this is default method");
    }

  }
  ```
  在实现类中, test()方法可以被其他方法直接调用, 也可以直接被对象调用

* 使用选择  

  * 使用接口：

    需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；
    需要使用多重继承。

  * 使用抽象类：

    需要在几个相关的类中共享代码。
    需要能控制继承来的成员的访问权限，而不是都为 public。
    需要继承非静态和非常量字段。

  在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。


-------------------

重写与重载
-----------

* 重写  

  重写应满足的条件:   
  1 子类方法访问权限为 public，大于父类的 protected。  
  2 子类的返回类型为 ArrayList，是父类返回类型 List 的子类。  
  3 子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。  
  4 子类重写方法使用 @Override 注解，从而让编译器自动检查是否满足限制条件。  

  ```java

    class SuperClass {
        protected List<Integer> func() throws Throwable {
            return new ArrayList<>();
        }
    }

    class SubClass extends SuperClass {
        @Override
        public ArrayList<Integer> func() throws Exception {
            return new ArrayList<>();
        }
    }

  ```
  重写方法的调用:  

  在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：

  this.func(this)  
  super.func(this)  
  this.func(super)  
  super.func(super)  

  ```java

    /*
        A
        |
        B
        |
        C
        |
        D
    */


    class A {

        public void show(A obj) {
            System.out.println("A.show(A)");
        }

        public void show(C obj) {
            System.out.println("A.show(C)");
        }
    }

    class B extends A {

        @Override
        public void show(A obj) {
            System.out.println("B.show(A)");
        }
    }

    class C extends B {
    }

    class D extends C {
    }

  ```


  ```java
  
    public static void main(String[] args) {

      A a = new A();
      B b = new B();
      C c = new C();
      D d = new D();

      // 在 A 中存在 show(A obj)，直接调用
      a.show(a); // A.show(A)
      // 在 A 中不存在 show(B obj)，将 B 转型成其父类 A
      a.show(b); // A.show(A)
      // 在 B 中存在从 A 继承来的 show(C obj)，直接调用
      b.show(c); // A.show(C)
      // 在 B 中不存在 show(D obj)，但是存在从 A 继承来的 show(C obj)，将 D 转型成其父类 C
      b.show(d); // A.show(C)

    }

  ```

* 重载  

  同一个类中存在多个**名称相同**的方法，但是参数类型、个数、顺序至少有一个不同。 调用时根据对应的参数调用对应的方法。

  应该注意的是，返回值不同，其它都相同不算是重载。

  ```java

    class MyClass {
        int height;
        MyClass() {
            System.out.println("无参数构造函数");
            height = 4;
        }
        MyClass(int i) {
            System.out.println("房子高度为 " + i + " 米");
            height = i;
        }
        void info() {
            System.out.println("房子高度为 " + height + " 米");
        }
        void info(String s) {
            System.out.println(s + ": 房子高度为 " + height + " 米");
        }
    }

    public class MainClass {
        public static void main(String[] args) {
            MyClass t = new MyClass(3); //房子高度为 3 米
            t.info(); //房子高度为 3 米
            t.info("重载方法"); //重载方法: 房子高度为 3 米
            //重载构造函数
            new MyClass(); //无参数构造函数
        }
    }

  ```

-------------------

java与C++的区别
-----------
* Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。  
* Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。  
* Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。  
* Java 支持自动垃圾回收，而 C++ 需要手动回收。  
* Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。  
* Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。  
* Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。  