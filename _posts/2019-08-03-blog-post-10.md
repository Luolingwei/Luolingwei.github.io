---
title: 'Java Foundation'
date: 2019-08-03
permalink: /posts/2019/08/blog-post-10/
tags:
  - Note
---

This is my personal notes for Java Foundation.


Introduction
------
本文介绍Java基础知识

定义
------
* Array refers to a bunch of elements of same type stored in consecutive memory.  
* ArrayList is dynamic array, the size of it can be changed, element could be add and remove from the list. (by Array)
* LinkedList is a linear data structure, in which elements are not stored in consecutive memory, each elements has 1 or more pointers to other elements. Typically, each element will be linked with the next element.  (by doubly Linked List)
* HashMap is a data structure which stores data in key-value pair, to access a value, we must get its key, it is called HashMap because it uses Hashing, which means transfer a data block to a fixed range. (by array+LinkedList+Red-Black Tree)
* HashSet is a data structure which stores unique element in random order,  no duplication is allowed, but there could be null. (by HashMap) 
* TreeMap is a ordered Map which is implemented by Red-Black Tree, the key is stored in natural order. (By Red-Black Tree)
* TreeSet is a Ordered Set which is implemented by Red-Black Tree, the elements are stored in natural order. (By Red-Black Tree)

集合
------
* List

List 和 Array的区别:  
* 虽然Array的随机访问和存储效率高，但其不可伸缩，初始化的时候必须指定Size，这使得数据动态更新很不方便。而List无需声明Size，方便插入删除

ArrayList 和 LinkedList的区别:  
* ArrayList底层用Array实现，随机访问速度快O(1)，插入删除速度慢(O(n)). 当有大量访问操作时，使用ArrayList
* LinkedList底层用doubly linked list实现，插入删除速度快(O(1))，随机访问速度慢(O(n)). 当有大量插入删除操作时，使用LinkedList  

```Java

  List<Integer> A=new ArrayList<>();
  List<Integer> B=new LinkedList<>();

  A.add(1) #在List末尾加入1 O(1)
  A.add(0,3) #在index=0的位置插入3，相当于insert O(n)
  A.remove(1) #删除索引为1的元素 O(n)
  A.remove(new Integer(1)) #删除元素 O(n)
  A.get(1) #取出索引为1的元素 O(1)

  A.addAll(A) #并入同类型的ArrayList
  A.size() #返回A中的元素个数
  A.isEmpty() #判断是否为空
  A.sort() #inplace 排序
  A.subList(0,2) #返回index为0和1的元素

  # LinkedList可以在头尾添加删除
  B.add(1) #在List末尾加入1 O(1) 
  B.add(0,3) #在index=0的位置插入3，相当于insert O(n)
  B.remove(1) #删除索引为1的元素 O(n)
  B.remove(new Integer(1)) #删除元素 O(n), 需要先找到包含该元素的node，O(n)+O(1)
  B.get(1) #取出索引为1的元素 O(n), 同样需要从链表头开始遍历

  B.addFirst() # O(1)
  B.addLast() # O(1)
  B.removeFirst() # O(1)
  B.removeLast()# O(1)

```

* Set

* HashSet is implemented by HashMap, the element in HashSet is actually key in HashMap, the value is set as Present in cooresponding HashMap, the element is unique because Key in HashMap is unique. When adding an element, call HashMap's put method, if key is already there, just update the value, adding will fail. Else adding wil succeed. When removing an element, call HashMap's remove function, if return value is Present, remove succeed. Else, remove will fail.

```Java

  Set<Character> B=new HashSet<>();
  Set<Character> C=new TreeSet<>();
  B.add('a'); #添加元素 
  B.remove('a'); #删除元素

  B.addAll(C) #B和C取并集
  B.size() #返回B的元素个数
  B.isEmpty() #判断是否为空
  B.sort() #返回排序后的List
  B.clear() #清空set

```

* Map  

HashMap和HashTable的区别:
* 1 HashMap is not thread-safe (not synchronised),  HashTable is thread-safe (synchronised)  
* 2 There can be "null" in key, value of HashMap, but there can not be "null" in HashTable
// synchronised: when mutiple threads visit the HashMap, only 1 of them could make modification 

 HashMap的底层实现:  
 * HashMap底层用Array+LinkedList+(红黑树)实现
 * 初始化长度为16的数组，每个数组元素存链表的头结点，key对16取余数得到Hashcode(在数组中的index)
 * 为了防止各个链表长度过长影响get方法，当链表长度达到8时，转为红黑树，提高map效率  

 HashMap出现Hash碰撞怎么处理的:  
 * 用链表存储相同HashCode的value
 * 取的时候先计算出HashCode，然后遍历链表中节点的key寻找target  

 HashMap为什么是线程不安全的:
 * When amount of data exceed threshold, the HashMap will be resized, all elements will be rehashed. Deadlock will appear in Muti-thread rehashing.

 ![avatar](https://pic2.zhimg.com/80/v2-54ce9985f42a76d96ae1f25d05e2eac5_hd.jpg)

TreeMap:  
* It implements the interface sortedMap, the key in TreeMap would be in stored in natural order.  
* If key is required to be in order, we can not use HashMap but use TreeMap instead.
* TreeMap is implemented using Red-Black Tree.


```Java

  Map<Character,Integer> dic=new Hashmap<>();
  Map<Character,Integer> dic2=new TreeMap<>();
  dic.get('a'); #如果key不存在, 返回null
  dic.put('b',1); #存入pair(b,1),如果key已存在则更新
  dic.getOrDefault('a',0) #如果'a'不存在，取0
  dic.containsKey('a'); #判断'a'是否是dic中的key
  dic.size(); #返回dic中pairs个数
  dic.remove('a'); #删除dic中key为'a'的pair
  dic.clear(); #清空HashMap

  dic.keySet(); #以Set形式返回所有的key
  Set<Character> keys=dic.keySet();
  dic.values(); #返回一个包含values的collection集合,可以进一步转型存储
  List<Integer> values=new ArrayList<Integer>(dic.values());

```

接口(Interface)
------
Java 定义的一个非常general的方法 (only method, no implementation)
Different class could have different implementation on it，which makes it suitable for different scenario. Making the interface very flexible.

Why not multiple inheritance:

  Java is designed to be single inheritance (1 child class only have 1 parent class)

  multiple inheritance would be unsafe, if several parent class have same functions, and they are inherited by same child class.

  but interface has no implementation, so different interfaces coould be implemented by same child class.
