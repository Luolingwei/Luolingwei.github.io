---
title: 'Java Foundation'
date: 2019-08-03
permalink: /posts/2019/08/blog-post-10/
tags:
  - Note
---

This is my personal notes for Java Foundation.


Introduction
------
本文介绍Java基础知识

-------------------

String，StringBuilder, StringBuffer
-----------

* String (不可变，线程安全)

  String类是final类，也即意味着String类不能被继承

  String是用char[]存储的, 其属性字段基本都是final的, 所以是不可变的  

  无论是sub、concat还是replace操作都不是inplace操作，而是重新生成了一个新的字符串对象


  * String直接赋值和new String()的区别

    * 直接赋值

      ```java
        String str1 = "hello";
        String str2 = "hello";
        String str3 = "world";
      ```
      生成了2个对象  
      这样创建字符串，首先会去常量池里找有没有这个字符串，有就直接指向常量池的该字符串，没有就先往常量池中添加一个，再指向它。图解：

      ![avatar](https://pic2.zhimg.com/80/v2-3b19aa93549d952756616011ef368e39_720w.jpg)

    * 用new创建

      ```java
        String str1 = new String("hello");
        String str2 = new String("hello");
        String str3 = new String("world");
      ```
      生成了5个对象  
      new一个字符串时，做了两件事。首先在堆中生成了该字符串对象，然后去看常量池中有没有该字符串，如果有就不管了，没有就往常量池中添加一个。图解：

      ![avatar](https://pic4.zhimg.com/80/v2-c8c7e43ffcbca3b6f69a01900901e2c7_720w.jpg)

    这两种方式创建的对象一种在常量池中一种在堆中, 所以用==比较会是false

  * StringBuilder(可变，线程不安全)

    String的+=操作底层是使用StringBuilder完成的  

    以下代码, JVM会优化成StringBuilder进行append, 循环10000次会在堆中new出10000个对象。

    ```java

      public class Main {
              
          public static void main(String[] args) {
              String string = "";
              for(int i=0;i<10000;i++){
                  string += "hello";
              }
          }

        // JVM执行方式
        StringBuilder str = new StringBuilder(string);

    　　str.append("hello");

    　　str.toString();
          
      }

    ```

    而如果直接使用StringBuilder, 则只会new一次对象, append操作是在原有对象的基础上进行的, 所占的资源要比上面小得多

    ```java

        public class Main {
                
            public static void main(String[] args) {
                StringBuilder stringBuilder = new StringBuilder();
                for(int i=0;i<10000;i++){
                    stringBuilder.append("hello");
                }
            }
        }

    ```

  * StringBuffer (可变，线程安全)

    StringBuffer和StringBuilder成员属性以及成员方法基本相同, 不同的是StringBuffer的方法前面都加上了**synchronized**, 所以StringBuffer是线程安全的。


  * 常见面试题

    * a String a = "hello2"; String b = "hello" + 2; System.out.println((a == b));

      输出结果为：true。原因很简单，"hello"+2在编译期间就已经被优化成"hello2"，因此在运行期间，变量a和变量b指向的是同一个对象。

    * b String a = "hello2"; String b = "hello"; String c = b + 2; System.out.println((a == c));

      输出结果为:false。由于有符号引用的存在，所以  String c = b + 2; 不会在编译期间被优化，不会把b+2当做常量来处理，因此这种方式生成的对象保存在堆上。而a保存在常量池中。

    * c String a = "hello2"; final String b = "hello"; String c = b + 2;    System.out.println((a == c));

      输出结果为：true。对于被final修饰的变量，会在class文件常量池中保存一个副本，也就是说不会通过连接而进行访问，对final变量的访问在编译期间都会直接被替代为真实的值。所以a和c都保存在常量池中。

    * d String str = new String("abc")创建了多少个对象？
    
      2个, 堆中1个, 常量池1个

    * e 1)和2)哪个更高效?  

      ```java
        public class Main {
            public static void main(String[] args) {
                String str1 = "I";
                //str1 += "love"+"java";        1)
                str1 = str1+"love"+"java";      //2)
                
            }
        }
      ```
      两者都会调用StringBuilder进行append, 1)的"love"+"java"会在编译时被优化成"lovejava", 而 2)会append两次。所以1)更高效。


-------------------

关键字
-----------

* 1 static

  * a 修饰成员变量  

    static关键字可以修饰成员变量，它所修饰的成员变量不属于对象的数据结构，而是属于类的变量，通常通过类名来引用static成员。

    当创建对象后，成员变量是存储在堆中的，而static成员变量和类的信息一起存储在方法区, 而不是在堆中

    一个类的static成员变量只有“一份”（存储在方法区）

    举例: 以下代码输出1, 2, 3, num对所有对象只有一份
    ```java

        class People {

            private int age;

            private static int num;

            public People(int age) {

              this.age = age;

              System.out.print(++num);

            }

        }

        public class StaticDemo {

            public static void main(String[] args) {

              People p1 = new People(18);

              People p2 = new People(19);

              People p3 = new People(20);

            }

        }

    ```

  * b 修饰方法

    static修饰的方法不需要针对某些对象进行操作，其运行结果仅仅与参数有关，调用的话直接用类名就可以调用了。(new 一个对象进行调用其实也可以)

        
    static方法中不能直接调用non-static方法, 但是可以间接通过对象的引用调用其non-static方法。


    ```java
      class Test2{
          public void method2(){
              System.out.println("HelloWorld2");
          }
      }

      class Test1 {

          public void method0(){
              System.out.println("HelloWorld0");
          }
          public static void method1() {
              System.out.println("HelloWorld1");
          }

          public static void main(String[] args) {
              // this.method0(); // 静态方法中不能用this, super等直接调用非静态方法
              new Test1().method0(); // 用对象的引用调用非静态方法method0
              Test1.method1(); // 直接用类名调用静态方法method1
              new Test2().method2(); // 用对象的引用调用非静态方法method2
          }

          // 输出
          // HelloWorld0
          // HelloWorld1
          // HelloWorld2
          
      }

    ```

  * c static块

      它是随着类的加载而执行，只执行一次，并优先于主函数。具体说，静态代码块是由类调用的。类调用时，先执行静态代码块，然后才执行主函数的。  
      静态代码块其实就是给类初始化的，而构造代码块是给对象初始化的。  
      静态代码块中的变量是局部变量，与普通函数中的局部变量性质没有区别。  
      一个类中可以有多个静态代码块

    ```java
        class Test1 {

            static int cnt=6;
            static{
                cnt+=9;
            }
            public static void main(String[] args) {
                System.out.println(cnt);
            }
            static{
                cnt/=3;
            }

        }

        // 输出
        // 5
    ```

  * d static类

      Java 的静态类只能是内部类, 其中的静态方法和成员可以直接通过内部类名在当前类被调用

      ```java
        class Test1 {

            private static class class1{
                static int i = 100;
            }

            public static void main(String[] args) {
                System.out.println(class1.i);
            }

        }

        // 输出
        // 100
      ```



* 2 final

  * a 修饰变量

    final意为不可改变，修饰成员变量时可以在声明时初始化或者在构造函数中初始化，修饰局部变量时在使用之前初始化。要是企图改变final修饰等变量值则会编译错误！

    ```java
      // 构造函数中初始化
      class Test1 {

          public final int cnt;

          Test1(){
              cnt = 4;
          }
          public static void main(String[] args) {
              System.out.println(new Test1().cnt);
          }

      }

      // 声明时初始化

      class Test1 {

          public final int cnt = 4;

          public static void main(String[] args) {
              System.out.println(new Test1().cnt);
          }

      }

    ```

  * b 修饰方法

    final修饰等方法不能被重写。

    ```java

      class Test1 {

          public final void method1(){
              System.out.println("this is method1");
          }

      }

      class Test2 extends Test1 {

          // 报错, method1不能被重写
          @Override
          public void method1() {
              super.method1();
          }
          
      }

    ```



  * c final修饰类

    final修饰等类不能被继承，jdk中的一些基本类库被定义成final，例如String，Math，Integer等，这样可以防止对系统造成危害。

    ```java

      final class Test1 {
          
      }

      // 报错, class Test1不可被继承
      class Test2 extends Test1{
          
          public static void main(String[] args) {
              System.out.println("Hello");
          }
          
      }

    ```

* 3 static final

  static final修饰的成员变量被成为常量，必须声明时初始化并且不可被改变，static final常量在编译期间会被取代为其初始值。

* 4 super

  访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super() 函数。  

  访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。

  ```java
    public class SuperExample {

        protected int x;
        protected int y;

        public SuperExample(int x, int y) {
            this.x = x;
            this.y = y;
        }

        public void func() {
            System.out.println("SuperExample.func()");
        }
    }


    public class SuperExtendExample extends SuperExample {

        private int z;

        public SuperExtendExample(int x, int y, int z) {
            super(x, y); // 调用父类的构造函数
            this.z = z;
        }

        @Override
        public void func() {
            super.func(); // 调用父类的实现部分
            System.out.println("SuperExtendExample.func()");
        }
    }

  ```



-------------------

参数传递
-----------

Java 的参数是以值传递的形式传入方法中，而不是引用传递  
传递对象时, 本质上是以值传递的方式传递地址

* Example1
  ```java
    class PassByValueExample {
        public static void main(String[] args) {
            Dog dog = new Dog("A");
            func(dog);
            System.out.println(dog.getName());          // B
        }

        private static void func(Dog dog) {
            dog.setName("B");
        }
    }
  ```
  将对象地址传进去, 修改之后对象属性会改变, 因为指向的是同一个对象

* Example2
  ```java
   class PassByValueExample {
        public static void main(String[] args) {
            Dog dog = new Dog("A");
            System.out.println(dog.getObjectAddress()); // Dog@4554617c
            func(dog);
            System.out.println(dog.getObjectAddress()); // Dog@4554617c
            System.out.println(dog.getName());          // A
        }

        private static void func(Dog dog) {
            System.out.println(dog.getObjectAddress()); // Dog@4554617c
            dog = new Dog("B");
            System.out.println(dog.getObjectAddress()); // Dog@74a14482
            System.out.println(dog.getName());          // B
        }
    }
  ```
  将对象地址传进去, 重新赋值, 会覆盖之前的地址, 生成新对象


-------------------

集合
-----------

(1) Array refers to a bunch of elements of same type stored in consecutive memory.    
(2) ArrayList is dynamic array, the size of it can be changed, element could be add and remove from the list. (by Array)  
(3) LinkedList is a linear data structure, in which elements are not stored in consecutive memory, each elements has 1 or more pointers to other elements. Typically, each element will be linked with the next element.  (by doubly Linked List)  
(4) HashMap is a data structure which stores data in key-value pair, to access a value, we must get its key, it is called HashMap because it uses Hashing, which means transfer a data block to a fixed range. (by array+LinkedList+Red-Black Tree)  
(5) HashSet is a data structure which stores unique element in random order,  no duplication is allowed, but there could be null. (by HashMap)   
(6) TreeMap is a ordered Map which is implemented by Red-Black Tree, the key is stored in natural order. (By Red-Black Tree)  
(7) TreeSet is a Ordered Set which is implemented by Red-Black Tree, the elements are stored in natural order. (By Red-Black Tree)  

![avatar](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208220948084.png)


* List

  List 和 Array的区别:  
  虽然Array的随机访问和存储效率高，但其不可伸缩，初始化的时候必须指定Size，这使得数据动态更新很不方便。而List无需声明Size，方便插入删除
 
  * ArrayList  
    底层用Array实现，随机访问速度快O(1)，中间位置插入删除速度慢(O(n))(需要调用System.arraycopy). 当有大量访问操作时，使用ArrayList

    ![avatar](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208232221265.png)

  * LinkedList  
    底层用doubly linked list实现，插入删除速度快(O(1))，随机访问速度慢(O(n)). 当有大量插入删除操作时，使用LinkedList  

    ![avatar](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208233940066.png)

  * Vector  
    和 ArrayList 类似，但它是线程安全的。
    和 ArrayList 不同, Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；  
    Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍。  

    vector的替代方案:  
    可以使用 Collections.synchronizedList(); 得到一个线程安全的 ArrayList。
    ```java
      List<String> list = new ArrayList<>();
      List<String> synList = Collections.synchronizedList(list);
    ```

  ```Java

    List<Integer> A=new ArrayList<>();
    LinkedList<Integer> B=new LinkedList<>();

    A.add(1) #在List末尾加入1 O(1)
    A.add(0,3) #在index=0的位置插入3，相当于insert O(n)
    A.remove(1) #删除索引为1的元素 O(n)
    A.remove(new Integer(1)) #删除元素 O(n)
    A.get(1) #取出索引为1的元素 O(1)

    A.addAll(A) #并入同类型的ArrayList
    A.size() #返回A中的元素个数
    A.isEmpty() #判断是否为空
    A.sort() #inplace 排序
    A.subList(0,2) #返回index为0和1的元素

    # LinkedList可以在头尾添加删除
    # 由于LinkedList O(1)的插入删除速度, 可以当做栈、队列和双向队列使用

    B.add(1) #在List末尾加入1 O(1) 
    B.add(0,3) #在index=0的位置插入3，相当于insert O(n)
    B.remove(1) #删除索引为1的元素 O(n)
    B.remove(new Integer(1)) #删除元素 O(n), 需要先找到包含该元素的node，O(n)+O(1)
    B.get(1) #取出索引为1的元素 O(n), 同样需要从链表头开始遍历

    B.addFirst() # O(1)
    B.addLast() # O(1)
    B.removeFirst() # O(1)
    B.removeLast()# O(1)

  ```

* Set

    Set不包含重复的元素，这是Set最大的特点，也是使用Set最主要的原因。常用到的Set实现有 HashSet，LinkedHashSet 和 TreeSet。一般地，如果需要一个访问快速的Set，应该使用HashSet；当需要一个排序的Set，应该使用TreeSet；当需要记录下插入时的顺序时，应该使用LinedHashSet。

  * HashSet  

    委托给HashMap进行实现，实现了Set接口, 支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。 add()、remove()以及contains()等方法都是复杂度为O(1)

    HashSet中的元素实际上是HashMap中的key, value设置为"Present", HashMap key的唯一性保证了HashSet元素的唯一性, 添加元素时, 调用map.put(key, PRESENT), 如果元素存在返回oldValue, 对应的add方法返回false. 如果元素不存在更新HashMap并返回null, add方法返回true。 Set中的元素为HashMap的keySet。
  
  * TreeSet

    委托给TreeMap(TreeMap实现了NavigableSet接口)进行实现，实现了NavigableSet接口(扩展的 SortedSet)

    TreeSet是采用红黑树结构实现，元素是按顺序进行排列，但是add()、remove()以及contains()等方法都是复杂度为O(log (n))的方法，它还提供了一些方法来处理排序的set，如first()、 last()、 headSet()和 tailSet()等。此外，TreeSet不同于HashSet和LinkedHashSet，其所存储的元素必须是可排序的(元素实现Comparable接口或者传入Comparator)，并且不能存放null值。
  

  * LinkedHashSet
  
    是HashSet的子类，被委托给HashMap的子类LinkedHashMap进行实现，实现了Set接口

    LinkedHashSet继承于HashSet，利用下面的HashSet构造函数即可，注意到，其为包访问权限，专门供LinkedHashSet的构造函数调用。LinkedHashSet性能介于HashSet和TreeSet之间，是HashSet的子类，也是一个hash表，但是同时维护了一个双链表来记录插入的顺序，基本方法的复杂度为O(1)。


    ```Java

      Set<Character> B=new HashSet<>();
      Set<Character> C=new TreeSet<>();
      Set<Character> D=new LinkedHashSet<>();

      B.add('a'); #添加元素 
      B.remove('a'); #删除元素

      B.addAll(C) #B和C取并集
      B.size() #返回B的元素个数
      B.isEmpty() #判断是否为空
      B.sort() #返回排序后的List
      B.clear() #清空set

    ```

* Queue

  * LinkedList：可以用它来实现双向队列。

  * PriorityQueue：基于堆结构实现，可以用它来实现优先队列。

* Map  

  ![avatar](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208224757855.png)


  * HashMap  

    ![avatar](https://pic2.zhimg.com/80/v2-54ce9985f42a76d96ae1f25d05e2eac5_hd.jpg)

    HashMap和HashTable的区别:
      * 1 HashMap 是线程不安全的 (not synchronised),  HashTable 是线程安全的(synchronised)  
      * 2 HashMap可以有null的key, 存储在第一个桶(null无法计算HashCode), 但是 HashTable 不能有null的key 
      // synchronised: when mutiple threads visit the HashMap, only 1 of them could make modification 

    HashMap的底层实现:  
      * HashMap底层用Array+LinkedList+(红黑树)实现
      * 初始化长度为16(如果不传为默认)的数组，每个数组元素存链表的头结点，HashCode对数组长度取余数得到桶下标(在数组中的index)
      * 为了防止各个链表长度过长影响get方法，当链表长度达到8时，转为红黑树，提高map效率   
      * 每个node存储hash, key, value, next   
      * 插入时采用头插法将节点插入链表  
      * JDK1.8开始, 一个桶存储的链表长度大于等于 8 时会将链表转换为红黑树
    
    HashMap出现Hash碰撞怎么处理的(拉链法):  
      * 用链表存储相同HashCode的**键值对**
      * get的时候根据Key去桶里找，如果是链表说明是冲突的，此时还需要检测Key是否相同 

    HashMap为什么要保证capacity为2的n次方:
      * 确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。
      * h & (length-1), 表示对数组长度取模, 即只保留length对应二进制位以下的值。
      * eg:   

        ```shell
            y       : 10110010  
            x-1     : 00001111  
            y&(x-1) : 00000010
        ```

    HashMap为什么是线程不安全的:
      * HashMap键值对数量超过阈值(capacity(默认16)*loadFactor(默认0.75))时, 整个HashMap会resize(桶扩大为2倍数量),  所有元素会被迁移到新桶。这是多线程操作可能会出现环形链表, 导致get的时候出现死循环。

        ![avatar](https://upload-images.jianshu.io/upload_images/7853175-ab75cd3738471507.png?imageMogr2/auto-orient/strip\|imageView2/2/w/1200/format/webp)

  * ConcurrentHashMap  

    JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。

    JDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。

  * HashTable  
    
    和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。与HashMap不同的是, 它不允许null键值对的出现

  * TreeMap  

    实现了sortedMap接口, key是排序好的, 基于红黑树实现。

  * LinkedHashMap  

    使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。

    HashMap中预留了3个空函数给LinkedHashMap, 后者做了重写
    ```java
      // Callbacks to allow LinkedHashMap post-actions
      void afterNodeAccess(Node<K,V> p) { }
      void afterNodeInsertion(boolean evict) { }
      void afterNodeRemoval(Node<K,V> p) { }
    ```
    afterNodeAccess: 当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。

    afterNodeInsertion: 在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。(一般是缓存数量超过上限时进行删除, 该方法默认返回false)

    afterNodeRemoval: 移除节点后, 断开节点与其他节点的link
    
    ![avatar](http://static.zybuluo.com/Rico123/2rqhftcyh53vx2b2c6mse8oe/LinkedHashMap.png)

    使用LinkedHashMap实现LRU  
      * 设定最大缓存空间 MAX_ENTRIES 为 3；  
      * 使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；  
      * 覆盖 removeEldestEntry() 方法实现(默认false,即一直添加不会有删除)，重写后, 在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。  
      ```java
      class LRUCache<K, V> extends LinkedHashMap<K, V> {
          private static final int MAX_ENTRIES = 3;

          protected boolean removeEldestEntry(Map.Entry eldest){
              return size() > MAX_ENTRIES;
          }

          LRUCache() {
              super(MAX_ENTRIES, 0.75f, true);
          }
      }

      public static void main(String[] args) {

          LRUCache<Integer, String> cache = new LRUCache<>();
          cache.put(1, "a");
          cache.put(2, "b");
          cache.put(3, "c");
          cache.get(1);
          cache.put(4, "d");
          System.out.println(cache.keySet());

      }
      ```

  ```Java

    Map<Character,Integer> dic=new Hashmap<>();
    Map<Character,Integer> dic2=new TreeMap<>();
    Map<Character,Integer> dic3=new LinkedHashMap<>();
    
    dic.get('a'); #如果key不存在, 返回null
    dic.put('b',1); #存入pair(b,1),如果key已存在则更新
    dic.getOrDefault('a',0) #如果'a'不存在，取0
    dic.containsKey('a'); #判断'a'是否是dic中的key
    dic.size(); #返回dic中pairs个数
    dic.remove('a'); #删除dic中key为'a'的pair
    dic.clear(); #清空HashMap

    dic.keySet(); #以Set形式返回所有的key
    Set<Character> keys=dic.keySet();
    dic.values(); #返回一个包含values的collection集合,可以进一步转型存储
    List<Integer> values=new ArrayList<Integer>(dic.values());

  ```


-------------------

抽象类(abstract class)和接口(Interface)
-----------
* 抽象类

  抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。

  抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。


* 接口

  接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个**完全抽象**的类，也就是说它不能有任何的方法实现。Java 8 开始, 接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。

  interface 的默认方法在其实现类中可以不实现直接使用, 也可以重写实现。  
  interface 的方法必须是public  
  interface 的成员变量必须是 static 和 final 类型的  

  example:
  ```java
  public interface VideoService {

    public default void test(){
        System.out.println("this is default method");
    }

  }
  ```
  在实现类中, test()方法可以被其他方法直接调用, 也可以直接被对象调用

* 使用选择  

  * 使用接口：

    需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；
    需要使用多重继承。

  * 使用抽象类：

    需要在几个相关的类中共享代码。
    需要能控制继承来的成员的访问权限，而不是都为 public。
    需要继承非静态和非常量字段。

  在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。


-------------------

重写与重载
-----------

* 重写  

  重写应满足的条件:   
  1 子类方法访问权限为 public，大于父类的 protected。  
  2 子类的返回类型为 ArrayList，是父类返回类型 List 的子类。  
  3 子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。  
  4 子类重写方法使用 @Override 注解，从而让编译器自动检查是否满足限制条件。  

  ```java

    class SuperClass {
        protected List<Integer> func() throws Throwable {
            return new ArrayList<>();
        }
    }

    class SubClass extends SuperClass {
        @Override
        public ArrayList<Integer> func() throws Exception {
            return new ArrayList<>();
        }
    }

  ```
  重写方法的调用:  

  在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：

  this.func(this)  
  super.func(this)  
  this.func(super)  
  super.func(super)  

  ```java

    /*
        A
        |
        B
        |
        C
        |
        D
    */


    class A {

        public void show(A obj) {
            System.out.println("A.show(A)");
        }

        public void show(C obj) {
            System.out.println("A.show(C)");
        }
    }

    class B extends A {

        @Override
        public void show(A obj) {
            System.out.println("B.show(A)");
        }
    }

    class C extends B {
    }

    class D extends C {
    }

  ```


  ```java
  
    public static void main(String[] args) {

      A a = new A();
      B b = new B();
      C c = new C();
      D d = new D();

      // 在 A 中存在 show(A obj)，直接调用
      a.show(a); // A.show(A)
      // 在 A 中不存在 show(B obj)，将 B 转型成其父类 A
      a.show(b); // A.show(A)
      // 在 B 中存在从 A 继承来的 show(C obj)，直接调用
      b.show(c); // A.show(C)
      // 在 B 中不存在 show(D obj)，但是存在从 A 继承来的 show(C obj)，将 D 转型成其父类 C
      b.show(d); // A.show(C)

    }

  ```

* 重载  

  同一个类中存在多个**名称相同**的方法，但是参数类型、个数、顺序至少有一个不同。 调用时根据对应的参数调用对应的方法。

  应该注意的是，返回值不同，其它都相同不算是重载。

  ```java

    class MyClass {
        int height;
        MyClass() {
            System.out.println("无参数构造函数");
            height = 4;
        }
        MyClass(int i) {
            System.out.println("房子高度为 " + i + " 米");
            height = i;
        }
        void info() {
            System.out.println("房子高度为 " + height + " 米");
        }
        void info(String s) {
            System.out.println(s + ": 房子高度为 " + height + " 米");
        }
    }

    public class MainClass {
        public static void main(String[] args) {
            MyClass t = new MyClass(3); //房子高度为 3 米
            t.info(); //房子高度为 3 米
            t.info("重载方法"); //重载方法: 房子高度为 3 米
            //重载构造函数
            new MyClass(); //无参数构造函数
        }
    }

  ```

-------------------

java与C++的区别
-----------
* Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。  
* Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。  
* Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。  
* Java 支持自动垃圾回收，而 C++ 需要手动回收。  
* Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。  
* Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。  
* Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。  