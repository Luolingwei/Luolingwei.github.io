---
title: 'Java Foundation'
date: 2019-08-03
permalink: /posts/2019/08/blog-post-10/
tags:
  - Note
---

This is my personal notes for Java Foundation.


Introduction
------
本文介绍Java基础知识

-------------------

定义
-----------
* Array refers to a bunch of elements of same type stored in consecutive memory.  
* ArrayList is dynamic array, the size of it can be changed, element could be add and remove from the list. (by Array)
* LinkedList is a linear data structure, in which elements are not stored in consecutive memory, each elements has 1 or more pointers to other elements. Typically, each element will be linked with the next element.  (by doubly Linked List)
* HashMap is a data structure which stores data in key-value pair, to access a value, we must get its key, it is called HashMap because it uses Hashing, which means transfer a data block to a fixed range. (by array+LinkedList+Red-Black Tree)
* HashSet is a data structure which stores unique element in random order,  no duplication is allowed, but there could be null. (by HashMap) 
* TreeMap is a ordered Map which is implemented by Red-Black Tree, the key is stored in natural order. (By Red-Black Tree)
* TreeSet is a Ordered Set which is implemented by Red-Black Tree, the elements are stored in natural order. (By Red-Black Tree)


-------------------

集合
-----------

* List

List 和 Array的区别:  
* 虽然Array的随机访问和存储效率高，但其不可伸缩，初始化的时候必须指定Size，这使得数据动态更新很不方便。而List无需声明Size，方便插入删除

ArrayList 和 LinkedList的区别:  
* ArrayList底层用Array实现，随机访问速度快O(1)，插入删除速度慢(O(n)). 当有大量访问操作时，使用ArrayList
* LinkedList底层用doubly linked list实现，插入删除速度快(O(1))，随机访问速度慢(O(n)). 当有大量插入删除操作时，使用LinkedList  

```Java

  List<Integer> A=new ArrayList<>();
  List<Integer> B=new LinkedList<>();

  A.add(1) #在List末尾加入1 O(1)
  A.add(0,3) #在index=0的位置插入3，相当于insert O(n)
  A.remove(1) #删除索引为1的元素 O(n)
  A.remove(new Integer(1)) #删除元素 O(n)
  A.get(1) #取出索引为1的元素 O(1)

  A.addAll(A) #并入同类型的ArrayList
  A.size() #返回A中的元素个数
  A.isEmpty() #判断是否为空
  A.sort() #inplace 排序
  A.subList(0,2) #返回index为0和1的元素

  # LinkedList可以在头尾添加删除
  B.add(1) #在List末尾加入1 O(1) 
  B.add(0,3) #在index=0的位置插入3，相当于insert O(n)
  B.remove(1) #删除索引为1的元素 O(n)
  B.remove(new Integer(1)) #删除元素 O(n), 需要先找到包含该元素的node，O(n)+O(1)
  B.get(1) #取出索引为1的元素 O(n), 同样需要从链表头开始遍历

  B.addFirst() # O(1)
  B.addLast() # O(1)
  B.removeFirst() # O(1)
  B.removeLast()# O(1)

```

* Set

* HashSet is implemented by HashMap, the element in HashSet is actually key in HashMap, the value is set as Present in corresponding HashMap, the element is unique because Key in HashMap is unique. When adding an element, call HashMap's put method, if key is already there, just update the value, adding will fail. Else adding wil succeed. When removing an element, call HashMap's remove function, if return value is Present, remove succeed. Else, remove will fail.

```Java

  Set<Character> B=new HashSet<>();
  Set<Character> C=new TreeSet<>();
  B.add('a'); #添加元素 
  B.remove('a'); #删除元素

  B.addAll(C) #B和C取并集
  B.size() #返回B的元素个数
  B.isEmpty() #判断是否为空
  B.sort() #返回排序后的List
  B.clear() #清空set

```

* Map  

HashMap和HashTable的区别:
* 1 HashMap is not thread-safe (not synchronised),  HashTable is thread-safe (synchronised)  
* 2 There can be "null" in key, value of HashMap, but there can not be "null" in HashTable  
// synchronised: when mutiple threads visit the HashMap, only 1 of them could make modification 

 HashMap的底层实现:  
 * HashMap底层用Array+LinkedList+(红黑树)实现
 * 初始化长度为16的数组，每个数组元素存链表的头结点，key对16取余数得到Hashcode(在数组中的index)
 * 为了防止各个链表长度过长影响get方法，当链表长度达到8时，转为红黑树，提高map效率  

 HashMap出现Hash碰撞怎么处理的:  
 * 用链表存储相同HashCode的value
 * 取的时候先计算出HashCode，然后遍历链表中节点的key寻找target  

 HashMap为什么是线程不安全的:
 * When amount of data exceed threshold, the HashMap will be resized, all elements will be rehashed. Deadlock will appear in Muti-thread rehashing.

 ![avatar](https://pic2.zhimg.com/80/v2-54ce9985f42a76d96ae1f25d05e2eac5_hd.jpg)

TreeMap:  
* It implements the interface sortedMap, the key in TreeMap would be in stored in natural order.  
* If key is required to be in order, we can not use HashMap but use TreeMap instead.
* TreeMap is implemented using Red-Black Tree.


```Java

  Map<Character,Integer> dic=new Hashmap<>();
  Map<Character,Integer> dic2=new TreeMap<>();
  dic.get('a'); #如果key不存在, 返回null
  dic.put('b',1); #存入pair(b,1),如果key已存在则更新
  dic.getOrDefault('a',0) #如果'a'不存在，取0
  dic.containsKey('a'); #判断'a'是否是dic中的key
  dic.size(); #返回dic中pairs个数
  dic.remove('a'); #删除dic中key为'a'的pair
  dic.clear(); #清空HashMap

  dic.keySet(); #以Set形式返回所有的key
  Set<Character> keys=dic.keySet();
  dic.values(); #返回一个包含values的collection集合,可以进一步转型存储
  List<Integer> values=new ArrayList<Integer>(dic.values());

```

-------------------

String，StringBuilder, StringBuffer
-----------

* String (不可变，线程安全)

  String类是final类，也即意味着String类不能被继承

  String是用char[]存储的, 其属性字段基本都是final的, 所以是不可变的  

  无论是sub、concat还是replace操作都不是inplace操作，而是重新生成了一个新的字符串对象


  * String直接赋值和new String()的区别

    * 直接赋值

      ```java
        String str1 = "hello";
        String str2 = "hello";
        String str3 = "world";
      ```
      生成了2个对象  
      这样创建字符串，首先会去常量池里找有没有这个字符串，有就直接指向常量池的该字符串，没有就先往常量池中添加一个，再指向它。图解：

      ![avatar](https://pic2.zhimg.com/80/v2-3b19aa93549d952756616011ef368e39_720w.jpg)

    * 用new创建

      ```java
        String str1 = new String("hello");
        String str2 = new String("hello");
        String str3 = new String("world");
      ```
      生成了5个对象  
      new一个字符串时，做了两件事。首先在堆中生成了该字符串对象，然后去看常量池中有没有该字符串，如果有就不管了，没有就往常量池中添加一个。图解：

      ![avatar](https://pic4.zhimg.com/80/v2-c8c7e43ffcbca3b6f69a01900901e2c7_720w.jpg)

    这两种方式创建的对象一种在常量池中一种在堆中, 所以用==比较会是false

  * StringBuilder(可变，线程不安全)

    String的+=操作底层是使用StringBuilder完成的  

    以下代码, JVM会优化成StringBuilder进行append, 循环10000次会在堆中new出10000个对象。

    ```java

      public class Main {
              
          public static void main(String[] args) {
              String string = "";
              for(int i=0;i<10000;i++){
                  string += "hello";
              }
          }

        // JVM执行方式
        StringBuilder str = new StringBuilder(string);

    　　str.append("hello");

    　　str.toString();
          
      }

    ```

    而如果直接使用StringBuilder, 则只会new一次对象, append操作是在原有对象的基础上进行的, 所占的资源要比上面小得多

    ```java

        public class Main {
                
            public static void main(String[] args) {
                StringBuilder stringBuilder = new StringBuilder();
                for(int i=0;i<10000;i++){
                    stringBuilder.append("hello");
                }
            }
        }

    ```

  * StringBuffer (可变，线程安全)

    StringBuffer和StringBuilder成员属性以及成员方法基本相同, 不同的是StringBuffer的方法前面都加上了**synchronized**, 所以StringBuffer是线程安全的。


  * 常见面试题

    * a String a = "hello2"; String b = "hello" + 2; System.out.println((a == b));

      输出结果为：true。原因很简单，"hello"+2在编译期间就已经被优化成"hello2"，因此在运行期间，变量a和变量b指向的是同一个对象。

    * b String a = "hello2"; String b = "hello"; String c = b + 2; System.out.println((a == c));

      输出结果为:false。由于有符号引用的存在，所以  String c = b + 2; 不会在编译期间被优化，不会把b+2当做常量来处理，因此这种方式生成的对象保存在堆上。而a保存在常量池中。

    * c String a = "hello2"; final String b = "hello"; String c = b + 2;    System.out.println((a == c));

      输出结果为：true。对于被final修饰的变量，会在class文件常量池中保存一个副本，也就是说不会通过连接而进行访问，对final变量的访问在编译期间都会直接被替代为真实的值。所以a和c都保存在常量池中。

    * d String str = new String("abc")创建了多少个对象？
    
      2个, 堆中1个, 常量池1个

    * e 1)和2)哪个更高效?  

      ```java
        public class Main {
            public static void main(String[] args) {
                String str1 = "I";
                //str1 += "love"+"java";        1)
                str1 = str1+"love"+"java";      //2)
                
            }
        }
      ```
      两者都会调用StringBuilder进行append, 1)的"love"+"java"会在编译时被优化成"lovejava", 而 2)会append两次。所以1)更高效。

-------------------

关键字
-----------

* 1 static

  * a 修饰成员变量  

    static关键字可以修饰成员变量，它所修饰的成员变量不属于对象的数据结构，而是属于类的变量，通常通过类名来引用static成员。

    当创建对象后，成员变量是存储在堆中的，而static成员变量和类的信息一起存储在方法区, 而不是在堆中

    一个类的static成员变量只有“一份”（存储在方法区）

    举例: 以下代码输出1, 2, 3, num对所有对象只有一份
    ```java

        class People {

            private int age;

            private static int num;

            public People(int age) {

              this.age = age;

              System.out.print(++num);

            }

        }

        public class StaticDemo {

            public static void main(String[] args) {

              People p1 = new People(18);

              People p2 = new People(19);

              People p3 = new People(20);

            }

        }

    ```

  * b 修饰方法

    static修饰的方法不需要针对某些对象进行操作，其运行结果仅仅与参数有关，调用的话直接用类名就可以调用了。(new 一个对象进行调用其实也可以)

        
    static方法中不能直接调用non-static方法, 但是可以间接通过对象的引用调用其non-static方法。


    ```java
      class Test2{
          public void method2(){
              System.out.println("HelloWorld2");
          }
      }

      class Test1 {

          public void method0(){
              System.out.println("HelloWorld0");
          }
          public static void method1() {
              System.out.println("HelloWorld1");
          }

          public static void main(String[] args) {
              // this.method0(); // 静态方法中不能用this, super等直接调用非静态方法
              new Test1().method0(); // 用对象的引用调用非静态方法method0
              Test1.method1(); // 直接用类名调用静态方法method1
              new Test2().method2(); // 用对象的引用调用非静态方法method2
          }

          // 输出
          // HelloWorld0
          // HelloWorld1
          // HelloWorld2
          
      }

    ```

  * c static块

      它是随着类的加载而执行，只执行一次，并优先于主函数。具体说，静态代码块是由类调用的。类调用时，先执行静态代码块，然后才执行主函数的。  
      静态代码块其实就是给类初始化的，而构造代码块是给对象初始化的。  
      静态代码块中的变量是局部变量，与普通函数中的局部变量性质没有区别。  
      一个类中可以有多个静态代码块

    ```java
        class Test1 {

            static int cnt=6;
            static{
                cnt+=9;
            }
            public static void main(String[] args) {
                System.out.println(cnt);
            }
            static{
                cnt/=3;
            }

        }

        // 输出
        // 5
    ```

  * d static类

      Java 的静态类只能是内部类, 其中的静态方法和成员可以直接通过内部类名在当前类被调用

      ```java
        class Test1 {

            private static class class1{
                static int i = 100;
            }

            public static void main(String[] args) {
                System.out.println(class1.i);
            }

        }

        // 输出
        // 100
      ```



* 2 final

  * a 修饰变量

    final意为不可改变，修饰成员变量时可以在声明时初始化或者在构造函数中初始化，修饰局部变量时在使用之前初始化。要是企图改变final修饰等变量值则会编译错误！

    ```java
      // 构造函数中初始化
      class Test1 {

          public final int cnt;

          Test1(){
              cnt = 4;
          }
          public static void main(String[] args) {
              System.out.println(new Test1().cnt);
          }

      }

      // 声明时初始化

      class Test1 {

          public final int cnt = 4;

          public static void main(String[] args) {
              System.out.println(new Test1().cnt);
          }

      }

    ```

  * b 修饰方法

    final修饰等方法不能被重写。

    ```java

      class Test1 {

          public final void method1(){
              System.out.println("this is method1");
          }

      }

      class Test2 extends Test1 {

          // 报错, method1不能被重写
          @Override
          public void method1() {
              super.method1();
          }
          
      }

    ```



  * c final修饰类

    final修饰等类不能被继承，jdk中的一些基本类库被定义成final，例如String，Math，Integer等，这样可以防止对系统造成危害。

    ```java

      final class Test1 {
          
      }

      // 报错, class Test1不可被继承
      class Test2 extends Test1{
          
          public static void main(String[] args) {
              System.out.println("Hello");
          }
          
      }

    ```

* 3 static final

  static final修饰的成员变量被成为常量，必须声明时初始化并且不可被改变，static final常量在编译期间会被取代为其初始值。


-------------------

接口(Interface)
-----------

Java 定义的一个非常general的方法 (only method, no implementation)
Different class could have different implementation on it，which makes it suitable for different scenario. Making the interface very flexible.

Why not multiple inheritance:

  Java is designed to be single inheritance (1 child class only have 1 parent class)

  multiple inheritance would be unsafe, if several parent class have same functions, and they are inherited by same child class. The child class would be confused on inheriting whose function. 

  but interface has no implementation, so different interfaces coould be implemented by same child class.
